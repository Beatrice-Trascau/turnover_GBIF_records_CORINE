---
title: "Forest to TWS JDI Data Exploration"
format: html
editor: visual
---

# Aims

This document outlines data exploration steps of the data used to model temporal turnover in land cover cells undergoing the Forest to Transitional Woodland Shrub transition.

```{r libraries}
#| label: packages
#| echo: false
#| include: false
library(here)
source(here("scripts", "0_setup.R"))
```

# All GBIF Occurrences

```{r data preparation}
#| label: data-prep
#| include: false

# Load Turnover data
load(here("data", "derived_data",
          "all_periods_turnover_all_land_cover_chanegs_15km.rda"))

# Select only columns for Forest -> TWS model
turnover_forest_tws_15km <- all_periods_turnover_all_land_cover_chanegs_15km |>
  select(-c('2000-2006_TWS no change', '2000-2006_TWS to Forest',
            '2000-2006_Urban_no_change', '2000-2006_all_to_urban',
            '2006-2012_TWS no change', '2006-2012_TWS to Forest',
            '2006-2012_Urban_no_change', '2006-2012_all_to_urban',
            '2012-2018_TWS no change', '2012-2018_TWS to Forest',
            '2012-2018_Urban_no_change', '2012-2018_all_to_urban')) |>
  # determine which rows belong to which time period
  mutate(forest_no_change = case_when(lc_time_period == "2000-2006" ~ `2000-2006_Forest no change`,
                                      lc_time_period == "2006-2012" ~ `2006-2012_Forest no change`,
                                      lc_time_period == "2012-2018" ~ `2012-2018_Forest no change`,
                                      TRUE ~ NA_real_),
         forest_to_tws = case_when(lc_time_period == "2000-2006" ~ `2000-2006_Forest to TWS`,
                                   lc_time_period == "2006-2012" ~ `2006-2012_Forest to TWS`,
                                   lc_time_period == "2012-2018" ~ `2012-2018_Forest to TWS`,
                                   TRUE ~ NA_real_)) |>
  # remove columns no longer required
  select(-`2000-2006_Forest no change`, -`2006-2012_Forest no change`, 
         -`2012-2018_Forest no change`,-`2000-2006_Forest to TWS`, 
         -`2006-2012_Forest to TWS`, -`2012-2018_Forest to TWS`)

# Transform JDI values for beta regression 

# Get N
N <- nrow(turnover_forest_tws_15km)

# Calculate new JDI values
turnover_forest_tws_15km <- turnover_forest_tws_15km |>
  mutate(JDI_beta = (JDI * (N - 1) + 0.5) / N)

```

## Summary Statistics

```{r summary stats}
#| label: summary-stats
#| echo: false

# Extract summary data
summary_by_period <- turnover_forest_tws_15km |>
  group_by(lc_time_period) |>
  summarize(n_observations = n(),
            mean_JDI = mean(JDI, na.rm = TRUE),
            sd_JDI = sd(JDI, na.rm = TRUE),
            mean_forest_to_tws = mean(forest_to_tws, na.rm = TRUE),
            sd_forest_to_tws = sd(forest_to_tws, na.rm = TRUE),
            mean_forest_no_change = mean(forest_no_change, na.rm = TRUE),
            sd_forest_no_change = sd(forest_no_change, na.rm = TRUE),
            mean_delta_recorder_effort = mean(delta_recorder_effort, na.rm = TRUE),
            mean_recorder_effort = mean(recorder_effort, na.rm = TRUE))

# Create table for period summary
summary_period_table <- summary_by_period |>
  kbl(caption = "Table 1: Summary Statistics by Time Period",
      digits = 3,
      align = c("l", rep("r", ncol(summary_by_period)-1))) |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = TRUE) |>
  column_spec(1, bold = TRUE) |>
  row_spec(0, bold = TRUE, background = "#E6F0FF") |>
  add_header_above(c(" " = 1, 
                     "Sample" = 1,
                     "Turnover" = 2, 
                     "Forest to TWS" = 2,
                     "Forest No Change" = 2,
                     "Recorder Effort" = 2))

# Print the table
summary_period_table

```

## Distribution of Variables

Firstly, we look at the distribution of values across each of the response variables used in our model.

```{r variables}
#| label: variables-distributions
#| echo: false

# Jaccard's Dissimilarity Index
jdi_hist <- ggplot(turnover_forest_tws_15km, aes(x = JDI)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Jaccard Dissimilarity Index",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Forest -> TWS
forest_to_tws_hist <- ggplot(turnover_forest_tws_15km, aes(x = forest_to_tws)) +
  geom_histogram(bins = 30, fill = "brown", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Forest to TWS Transition (pixel count)",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Forest No Change
forest_no_change_hist <- ggplot(turnover_forest_tws_15km, aes(x = forest_no_change)) +
  geom_histogram(bins = 30, fill = "darkgreen", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Forest No Change (pixel count)",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Recorder effort
recorder_effort_plot <- ggplot(turnover_forest_tws_15km, aes(x = recorder_effort)) +
  geom_histogram(bins = 30, fill = "orange", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Recorder Effort",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Delta recorder effort
delta_recorder_effort_plot <- ggplot(turnover_forest_tws_15km, aes(x = delta_recorder_effort)) +
  geom_histogram(bins = 30, fill = "coral", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Delta Recorder Effort",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Combine plots
plots <- plot_grid(jdi_hist, forest_to_tws_hist, forest_no_change_hist, recorder_effort_plot, delta_recorder_effort_plot, ncol = 2, labels = c("a)", "b)", "c)", "d)", "e)"))

# Print plots
plots
```

## Correlation Matrix

Then, we will also check the correlation between the variables used in the analysis.

```{r variable relationships}
#| label: variables-relationships
#| echo: false

# Correlation matrix for numeric variables
numeric_vars <- turnover_forest_tws_15km |>
  select(JDI, forest_to_tws, forest_no_change, 
         intersection_size, union_size, 
         total_spp_before, total_spp_after,
         total_occ_before, total_occ_after,
         recorder_effort, delta_recorder_effort)

# Calculate correlation matrix
cor_matrix <- cor(numeric_vars, use = "pairwise.complete.obs")

# Create correlation plot
cor_plot <- corrplot(cor_matrix, 
                     method = "circle", 
                     type = "upper", 
                     tl.col = "black", 
                     tl.srt = 45, 
                     addCoef.col = "black", 
                     number.cex = 0.7,
                     diag = FALSE)
```

Fortunately, we see no concerningly large correlations between variables used in the analysis.

## Outliers

Data exploration revealed that the data contains some large outliers.

```{r outlier summary}
#| label: outlier-summary
#| echo: false

# Load the forest -> TWS raster for spatial reference
clc_status_15km_forest_tws_masked <- rast(here("data", "derived_data", 
                                               "clc_status_15km_forest_tws_masked.tif"))

# 1. IDENTIFY OUTLIERS ---------------------------------------------------------

# Calculate quartiles and IQR for forest_to_tws
q1_forest <- quantile(turnover_forest_tws_15km$forest_to_tws, 0.25, na.rm = TRUE)
q3_forest <- quantile(turnover_forest_tws_15km$forest_to_tws, 0.75, na.rm = TRUE)
iqr_forest <- q3_forest - q1_forest
upper_forest <- q3_forest + 1.5 * iqr_forest
lower_forest <- q1_forest - 1.5 * iqr_forest

# Calculate quartiles and IQR for recorder_effort
q1_effort <- quantile(turnover_forest_tws_15km$recorder_effort, 0.25, na.rm = TRUE)
q3_effort <- quantile(turnover_forest_tws_15km$recorder_effort, 0.75, na.rm = TRUE)
iqr_effort <- q3_effort - q1_effort
upper_effort <- q3_effort + 1.5 * iqr_effort
lower_effort <- q1_effort - 1.5 * iqr_effort

# Flag outliers
turnover_forest_tws_15km <- turnover_forest_tws_15km |>
  mutate(forest_outlier = forest_to_tws > upper_forest | forest_to_tws < lower_forest,
         effort_outlier = recorder_effort > upper_effort | recorder_effort < lower_effort,
         any_outlier = forest_outlier | effort_outlier,
         outlier_type = case_when(forest_outlier & effort_outlier ~ "Both",
                                  forest_outlier ~ "Forest->TWS",
                                  effort_outlier ~ "Recorder Effort",
                                  TRUE ~ "None"))

# Print outlier summary
cat("=== OUTLIER SUMMARY ===\n")
cat("Forest->TWS outliers:", sum(turnover_forest_tws_15km$forest_outlier, na.rm = TRUE), "\n")
cat("Recorder Effort outliers:", sum(turnover_forest_tws_15km$effort_outlier, na.rm = TRUE), "\n")
cat("Total cells with any outlier:", sum(turnover_forest_tws_15km$any_outlier, na.rm = TRUE), "\n")
cat("Forest->TWS threshold:", round(upper_forest, 2), "\n")
cat("Recorder Effort threshold:", round(upper_effort, 2), "\n")
```

```{r outlier interactive map}
#| label: outlier-map
#| echo: false

# 2. CONVERT TO SPATIAL DATA ---------------------------------------------------

# Convert to sf object for mapping
turnover_sf <- st_as_sf(turnover_forest_tws_15km,
                        coords = c("x", "y"),
                        crs = st_crs(clc_status_15km_forest_tws_masked))

# Transform to WGS84 for leaflet
turnover_sf_wgs84 <- st_transform(turnover_sf, crs = 4326)

# 3. CREATE INTERACTIVE MAPS --------------------------------------------------- 

# Create color palette for forest_to_tws
forest_pal <- colorNumeric(palette = viridis::viridis(100),
                           domain = turnover_sf_wgs84$forest_to_tws,
                           na.color = "transparent")

# Create base map
forest_map <- leaflet() |>
  addProviderTiles("CartoDB.Positron") |>
  setView(lng = 10.7522, lat = 64.1, zoom = 5)

# Add each time period as a separate layer group
for(period in unique(turnover_sf_wgs84$lc_time_period)) {
  period_data <- turnover_sf_wgs84[turnover_sf_wgs84$lc_time_period == period, ]
  
  forest_map <- forest_map |>
    addCircleMarkers(data = period_data, group = period, radius = 3,
                     fillColor = ~forest_pal(forest_to_tws),
                     color = "white", weight = 0.5, opacity = 1,
                     fillOpacity = 0.8, 
                     popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                                     "<b>Period:</b> ", lc_time_period, "<br>",
                                     "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                                     "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                                     "<b>JDI:</b> ", round(JDI, 3), "<br>",
                                     "<b>Outlier Type:</b> ", outlier_type),
                     label = ~paste0("Forest->TWS: ", round(forest_to_tws, 2), " (", lc_time_period, ")"))
}

# Add layer control and legend
forest_map <- forest_map |>
  addLayersControl(overlayGroups = unique(turnover_sf_wgs84$lc_time_period),
                   options = layersControlOptions(collapsed = FALSE)) |>
  addLegend(pal = forest_pal, values = turnover_sf_wgs84$forest_to_tws,
            title = "Forest -> TWS<br>(100m pixels)",position = "bottomright")

# Create colour pallete for recorder effort
effort_pal <- colorNumeric(palette = viridis::plasma(100),
                           domain = turnover_sf_wgs84$recorder_effort,
                           na.color = "transparent")

# Create bse map for recorder effort
effort_map <- leaflet() |>
  addProviderTiles("CartoDB.Positron") |>
  setView(lng = 10.7522, lat = 64.1, zoom = 5)

# Add each time period as a separate layer group
for(period in unique(turnover_sf_wgs84$lc_time_period)) {
  period_data <- turnover_sf_wgs84[turnover_sf_wgs84$lc_time_period == period, ]
  
  effort_map <- effort_map |>
    addCircleMarkers(data = period_data, group = period, radius = 3,
      fillColor = ~effort_pal(recorder_effort), color = "white", weight = 0.5,
      opacity = 1, fillOpacity = 0.8,
      popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                      "<b>Period:</b> ", lc_time_period, "<br>",
                      "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                      "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                      "<b>JDI:</b> ", round(JDI, 3), "<br>",
                      "<b>Outlier Type:</b> ", outlier_type),
      label = ~paste0("Recorder Effort: ", recorder_effort, " (", lc_time_period, ")"))
}

# Add layer control and legend to recorder effort map
effort_map <- effort_map |>
  addLayersControl(overlayGroups = unique(turnover_sf_wgs84$lc_time_period),
                   options = layersControlOptions(collapsed = FALSE)) |>
  addLegend(pal = effort_pal,
            values = turnover_sf_wgs84$recorder_effort,
            title = "Recorder Effort<br>(total occurrences)",
            position = "bottomright")

# Outlier Map with outlier type control 
outlier_colors <- c("Forest->TWS" = "red", 
                    "Recorder Effort" = "blue", 
                    "Both" = "purple",
                    "None" = "lightgrey")

# Add base map for outliers
outlier_map <- leaflet() |>
  addProviderTiles("CartoDB.Positron") |>
  setView(lng = 10.7522, lat = 64.1, zoom = 5)


# Add Forest->TWS outliers as one layer
forest_outliers <- turnover_sf_wgs84[turnover_sf_wgs84$forest_outlier == TRUE, ]
outlier_map <- outlier_map |>
  addCircleMarkers(data = forest_outliers,
                   group = "Forest->TWS Outliers",
                   fillColor = "red",
                   color = "white",
                   weight = 0.5,
                   opacity = 1,
                   fillOpacity = 0.9,
                   popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                                   "<b>Period:</b> ", lc_time_period, "<br>",
                                   "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                                   "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                                   "<b>JDI:</b> ", round(JDI, 3), "<br>",
                                   "<b>Outlier Type:</b> ", outlier_type, "<br>",
                                   "<b>SSB ID:</b> ", ssb_id),
                   label = ~paste0("Forest->TWS Outlier: ", round(forest_to_tws, 2), " (", lc_time_period, ")"))

# Add Recorder Effort outliers as another layer
effort_outliers <- turnover_sf_wgs84[turnover_sf_wgs84$effort_outlier == TRUE, ]
outlier_map <- outlier_map |>
  addCircleMarkers(data = effort_outliers, group = "Recorder Effort Outliers",
                   radius = 5, fillColor = "blue", color = "white", weight = 0.5,
                   opacity = 1, fillOpacity = 0.9,
                   popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                                   "<b>Period:</b> ", lc_time_period, "<br>",
                                   "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                                   "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                                   "<b>JDI:</b> ", round(JDI, 3), "<br>",
                                   "<b>Outlier Type:</b> ", outlier_type, "<br>",
                                   "<b>SSB ID:</b> ", ssb_id),
                   label = ~paste0("Recorder Effort Outlier: ", recorder_effort, " (", lc_time_period, ")"))

# Add cells with both types of outliers
both_outliers <- turnover_sf_wgs84[turnover_sf_wgs84$outlier_type == "Both", ]
outlier_map <- outlier_map |>
  addCircleMarkers(data = both_outliers, group = "Both Types", radius = 6,
                   fillColor = "purple", color = "white", weight = 0.5,
                   opacity = 1, fillOpacity = 0.9,
                   popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                                   "<b>Period:</b> ", lc_time_period, "<br>",
                                   "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                                   "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                                   "<b>JDI:</b> ", round(JDI, 3), "<br>",
                                   "<b>Outlier Type:</b> ", outlier_type, "<br>",
                                   "<b>SSB ID:</b> ", ssb_id),
                   label = ~paste0("Both Outliers (", lc_time_period, ")"))

# Add non-outliers as a background layer (optional, lighter/smaller)
non_outliers <- turnover_sf_wgs84[turnover_sf_wgs84$any_outlier == FALSE, ]
outlier_map <- outlier_map |>
  addCircleMarkers(data = non_outliers, group = "Non-outliers", radius = 1.5,
                   fillColor = "lightgrey", color = "white", weight = 0.3,
                   opacity = 0.7, fillOpacity = 0.3, 
                   popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                                   "<b>Period:</b> ", lc_time_period, "<br>",
                                   "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                                   "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                                   "<b>JDI:</b> ", round(JDI, 3), "<br>",
                                   "<b>Outlier Type:</b> ", outlier_type, "<br>",
                                   "<b>SSB ID:</b> ", ssb_id),
                   label = ~paste0("Normal cell (", lc_time_period, ")"))

# Add layer controls for outlier types
outlier_type_map <- outlier_map |>
  addLayersControl(overlayGroups = c("Forest->TWS Outliers", "Recorder Effort Outliers", 
                      "Both Types", "Non-outliers"),
                   options = layersControlOptions(collapsed = FALSE)) |>
  addLegend(colors = c("red", "blue", "purple", "lightgrey"),
            labels = c("Forest->TWS Outliers", "Recorder Effort Outliers", 
               "Both Types", "Non-outliers"),
            title = "Outlier Categories",
            position = "bottomright")

# Print map
outlier_type_map
```

```{r outlier table}
#| label: outlier-table
#| echo: false

# 6. CREATE OUTLIER DATA TABLE ------------------------------------------------

# Create a detailed table of outliers
outlier_table <- turnover_forest_tws_15km |>
  filter(any_outlier) |>
  select(cell_ID, lc_time_period, forest_to_tws, recorder_effort, JDI, 
         outlier_type, ssb_id, x, y) |>
  arrange(desc(forest_to_tws))

# Display interactive table 
DT::datatable(outlier_table, 
              options = list(pageLength = 20, scrollX = TRUE),
              caption = "Outlier Cells Summary") |>
  DT::formatRound(columns = c("forest_to_tws", "JDI", "x", "y"), digits = 3)

```

```{r top outliers}
#| label: top-outlier
#| echo: false

# 7. PRINT TOP OUTLIERS -------------------------------------------------------

# Top 10 Forest -> TWS Outliers
top_forest_outliers <- turnover_forest_tws_15km |>
  filter(forest_outlier) |>
  arrange(desc(forest_to_tws)) |>
  slice_head(n = 10) |>
  select(cell_ID, lc_time_period, forest_to_tws, recorder_effort, JDI)

knitr::kable(top_forest_outliers, 
             caption = "Top 10 Forest->TWS Outliers",
             digits = 3)

# Top 10 Recorder Effort Outliers
top_effort_outliers <- turnover_forest_tws_15km |>
  filter(effort_outlier) |>
  arrange(desc(recorder_effort)) |>
  slice_head(n = 10) |>
  select(cell_ID, lc_time_period, forest_to_tws, recorder_effort, JDI)

knitr::kable(top_effort_outliers,
             caption = "Top 10 Recorder Effort Outliers", 
             digits = 3)
```

## Modeling

### $\beta$ regression

The models will be run with a $\beta$ distribution. However, since the raw $JDI\in [0,1]$ and the $\beta$ distribution assumes $JDI\in (0,1)$, the JDI values will be transformed according to the formula:

$$\frac{Y*(N-1)+0.5}{N}$$

where Y = the response variable and N = sample size.

For more details on the use of $\beta$ distribution for (0,1) values, see: Beta regression in R. Cibrari-Neto & Zeileis. Journal of Statistical Software. April 2010, Volume 34, Issue 2.

The following $\beta$ regression was run:

```{r beta regression}
#| label: beta-regression
#| echo: false

# 1. TRANSFORM JDI VALUES FOR BETA REGRESSION -------------------------------

# Get N
N <- nrow(turnover_forest_tws_15km)

# Calculate new JDI values
turnover_forest_tws_15km <- turnover_forest_tws_15km |>
  mutate(JDI_beta = (JDI * (N - 1) + 0.5) / N)

# 2. RUN BETA GLM --------------------------------------------------------------

# Run model
model1.1 <- betareg::betareg(JDI_beta ~ forest_to_tws + forest_no_change + 
                               delta_recorder_effort + recorder_effort + lc_time_period,
                             data = turnover_forest_tws_15km)

# Extarct residuals from model
model1.1_residuals <- residuals(model1.1)

# Add residuals to df
turnover_forest_tws_15km$residuals <- model1.1_residuals

# Get summary
model_summary <- tidy(model1.1, conf.int = TRUE)

# Display summary
knitr::kable(model_summary,
             caption = "Beta Regression Results: Forest->TWS Land Cover Change",
             digits = 4)

# Dispaly model fit statistics
model_glance <- glance(model1.1)
knitr::kable(model_glance,
             caption = "Model Fit Statistics",
             digits = 4)
```

```{r Morans I}
#| label: morans-i
#| echo: false

# 4. CHECK SPATIAL AUTOCORRELATION OF RESIDUALS --------------------------------

## 4.1. Prepare data for testing of autocorrelation ----------------------------

# Create reference grid
reference_grid <- clc_status_15km_forest_tws_masked[[1]]

# Convert turnover df to sf object
turnover_sf <- st_as_sf(turnover_forest_tws_15km,
                        coords = c("x", "y"),
                        crs = st_crs(reference_grid))

## 4.2. Create spatial neighbours ----------------------------------------------

# Create a neighbour list using k-nearest neighbours (k = 5)
coords_matrix <- st_coordinates(turnover_sf)
neighbours <- knn2nb(knearneigh(coords_matrix, k = 5))

# Convert to spatial weights matrix
weights <- nb2listw(neighbours, style = "W")

## 4.3. Calculate Moran's I ----------------------------------------------------

# Compute Moran's I test for spatial autocorrelation
moran_test <- moran.test(turnover_sf$residuals, listw = weights)

# Print results
moran_results <- data.frame(Statistic = c("Moran I", "Expectation", "Variance", "Standard deviate", "P-value"),
                            Value = c(moran_test$estimate[1], 
                                      moran_test$estimate[2], 
                                      moran_test$estimate[3],
                                      moran_test$statistic,
                                      moran_test$p.value))
# Display output
knitr::kable(moran_results,
             caption = "Moran's I Test for Spatial Autocorrelation of Model Residuals",
             digits = 6,
             col.names = c("Test Statistic", "Value"))

# Create Moran scatterplot to visualise the relationship
# moran_plot <- moran.plot(turnover_sf$residuals, listw = weights,
#                          xlab = "Model Residuals", 
#                          ylab = "Spatially Lagged Residuals")

# 5. PLOT MORAN'S I RESULTS ----------------------------------------------------

## 5.1. Calculate local Moran's I values ---------------------------------------

# Calculate local Moran's I wiht zero.policy
local_moran <- localmoran(turnover_sf$residuals, weights, zero.policy = TRUE)

# Add local Moran's I statistics to the spatial dataframe
turnover_sf$local_moran_i <- local_moran[, 1] # I statistics
turnover_sf$local_moran_p <- local_moran[, 5] # p-value

## 5.2. Handle missing values --------------------------------------------------

# Check for missing values in Moran's I column
# missing_values <- sum(is.na(turnover_sf$local_moran_i))
# cat("Number of cells with missing Local Moran's I values:", missing_values, "\n") #0

# Filter out NA for mapping
turnover_sf_clean <- turnover_sf |>
  filter(!is.na(local_moran_i))

## 5.3. Map of local Moran I values --------------------------------------------

# Extract coordinates
coords <- st_coordinates(turnover_sf)
turnover_df <- cbind(st_drop_geometry(turnover_sf), coords)

# Plot map
plot1 <- ggplot(turnover_df |> 
                  filter(!is.na(local_moran_i)), 
                aes(x = X, y = Y, fill = local_moran_i)) +
  geom_tile() +
  scale_fill_viridis_c(option = "viridis", name = "Local Moran's I") +
  theme_classic() +
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank())

# Save map
# ggsave(here("figures", "SupplementaryFigure4a_Local_Moran_I_Forest_TWS_15km.png"),
#        plot1, width = 10, height = 8)


## 5.3. Map of significance of local Moran's I values --------------------------

# Plot map
plot2 <- ggplot(turnover_df |> 
                  filter(!is.na(local_moran_i)), 
                aes(x = X, y = Y, fill = local_moran_p < 0.01)) +
  geom_tile() +
  scale_fill_manual(values = c("TRUE" = "red", "FALSE" = "grey"),
                    name = "Significant",
                    labels = c("FALSE" = "Not significant", "TRUE" = "p < 0.001")) +
  theme_classic() +
  theme(panel.grid = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.line = element_blank(),
          axis.ticks = element_blank())

# Save figure 
# ggsave(here("figures", "SupplementaryFigure4b_Local_Moran_I_Significance_Forest_TWS_15km.png"),
#        plot1, width = 10, height = 8)

## 5.4. Map of significant Moran's I with positive/negative residuals -----------

# Create categorical variable that combines significance and residual sign
turnover_df <- turnover_df |>
  mutate(sig_residual_type = case_when(local_moran_p < 0.01 & residuals > 0 ~ "Significant Positive",
                                       local_moran_p < 0.01 & residuals < 0 ~ "Significant Negative",
                                       local_moran_p >= 0.01 ~ "Not Significant"))

# Plot map of significant clusters with positive/negative residuals
plot3 <- ggplot(turnover_df |>
                  filter(!is.na(local_moran_i)), 
                aes(x = X, y = Y, fill = sig_residual_type)) +
  geom_tile() +
  scale_fill_manual(values = c("Significant Positive" = "pink", 
                               "Significant Negative" = "lightblue",
                               "Not Significant" = "grey"),
                    name = "Residual Type") +
  theme_classic() +
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank())

## 5.5. Combine into single plot -----------------------------------------------

# Combine plots
forest_tws_15km_local_morans_I <- plot_grid(plot1, plot2, plot3,
                                            labels = c("a)", "b)", "c)"),
                                            nrow = 2, align = "h")

# Display plot
forest_tws_15km_local_morans_I

# Save to file
# ggsave(here("figures", "SupplementaryFigure4_Local_Moran_I_Forest_TWS_15km.png"),
#        forest_tws_15km_local_morans_I, width = 18, height = 8)
```

Moran's I test for spatial autocorrelation revealed that there is significant spatial autocorrelation. Therefore, this needs to be accounted for to improve model predictions.

### Option 1: GLMM with SSB ID as random effect

```{r glmm with ssb}
#| label: glmm-ssb
#| eval: false
#| echo: false


# Run model
model1.1_mixed <- glmmTMB(JDI_beta ~ forest_to_tws + forest_no_change + 
                            delta_recorder_effort + recorder_effort + lc_time_period + 
                            (1|ssb_id),
                          family = beta_family(),
                          data = turnover_forest_tws_15km)

# Check output
summary(model1.1_mixed) #NaNs
```

The mixed models were attempted with both a 50km x 50km and 250km x 250km SSB ID grid. However, the output for the model was NaN across all estimates.

### Option 2: Ordered $\beta$

```{r ordered beta}
#| label: ordered-beta
#| eval: false
#| echo: false

# Ordered beta regression with random effects
model4_ordbeta <- ordbetareg(JDI ~ forest_to_tws + forest_no_change + 
                                 delta_recorder_effort + recorder_effort + lc_time_period + 
                                 (1|ssb_id),
                               data = turnover_forest_tws_15km,
                               cores = 4)

# Get summary
summary(model4_ordbeta) # model did not converge
```

Ordered $\beta$ models allow for $JDI\in [0,1]$, therefore, the values no longer need to be adjusted. However, this model failed to converge until the number of interactions was doubled and sampling was changed to be more conservative. However, model validation revealed that residuals were overdispersed.

```{r conservative ordered beta}
#| label: conservative-ordered-beta
#| eval: false
#| echo: false


# Increase iterations and chains (to try to fix convergence issues)
model5_ordbeta <- ordbetareg(JDI ~ forest_to_tws + forest_no_change + 
                                 delta_recorder_effort + recorder_effort + lc_time_period + 
                                 (1|ssb_id),
                               data = turnover_forest_tws_15km,
                               cores = 4,
                               iter = 4000,        # double the iterations
                               chains = 4,
                               control = list(adapt_delta = 0.95,  # more conservative sampling
                                              max_treedepth = 12))

# Check convergence
summary(model5_ordbeta)

# Plot output
plot(model5_ordbeta)
```

### Option 3: GLS with exponential correlation structure

General Least Squares (GLS) regression models with an exponential correlation structure around x and y were used. Since some cells are present in the dataframe at different time points, the GLS will interpret them as "duplicates", unless the time is also considered in the correlation structure.

```{r gls raw diagnostics}
#| label: raw-gls
#| echo: false
#| fig-width: 12
#| fig-height: 8
#| fig-cap: "Diagnostic plots for GLS model 1"

# Load model & data
load(here("data", "models", "gls_model1_all_occurrences_turnover_results.RData"))

# Extract data for plotting
fitted_values <- fitted(model1_gls)
residuals_norm <- residuals(model1_gls, type = "normalized")


# Residuals vs Fitted plot
p1 <- ggplot(data.frame(fitted = fitted_values, residuals = residuals_norm), 
             aes(x = fitted, y = residuals)) +
  geom_point(alpha = 0.6, color = "steelblue", size = 1.2) +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed", size = 1) +
  geom_smooth(method = "loess", se = TRUE, color = "darkred", alpha = 0.2) +
  labs(x = "Fitted Values", 
       y = "Normalized Residuals",
       title = "Residuals vs Fitted Values") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# QQ plot
qq_data <- data.frame(theoretical = qqnorm(residuals_norm, plot.it = FALSE)$x,
                      sample = qqnorm(residuals_norm, plot.it = FALSE)$y)

p2 <- ggplot(qq_data, aes(x = theoretical, y = sample)) +
  geom_point(alpha = 0.6, color = "steelblue", size = 1.2) +
  geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed", size = 1) +
  labs(x = "Theoretical Quantiles", 
       y = "Sample Quantiles",
       title = "Normal Q-Q Plot") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# Residuals vs Forest to TWS
p3 <- ggplot(data.frame(residuals = residuals_norm), aes(x = residuals)) +
  geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7, color = "white") +
  geom_density(aes(y = after_stat(density) * length(residuals_norm) * (max(residuals_norm) - min(residuals_norm)) / 30), 
               color = "red", size = 1) +
  labs(x = "Normalized Residuals", 
       y = "Frequency",
       title = "Distribution of Residuals") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# Residuals vs Recorder Effort
p4 <- ggplot(data.frame(fitted = fitted_values, sqrt_abs_resid = sqrt(abs(residuals_norm))), 
             aes(x = fitted, y = sqrt_abs_resid)) +
  geom_point(alpha = 0.6, color = "steelblue", size = 1.2) +
  geom_smooth(method = "loess", se = TRUE, color = "darkred", alpha = 0.2) +
  labs(x = "Fitted Values", 
       y = "√|Normalized Residuals|",
       title = "Scale-Location Plot") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# Combine plots
gls1_plots <- plot_grid(p1, p2, p3, p4, ncol = 2, labels = c("a)", "b)", "c)", "d)"))

# Dispaly combined plots
gls1_plots
```

Inspection of the diagnostic plots revealed that:

1.  Residuals vs Fitted:
    -   Most residuals are centered around 0
    -   But there is an uneven spread of residuals, with larger variance at higher fitted values
    -   There is a clustered pattern around 0.8-0.9 fitted values
    -   All of this suggests that there is some non-constant variance (i.e. hereoscedasticity) and possibly some non-linearity
2.  QQ Plot:
    -   The points mostly follow red line but depart from it at both ends
    -   This might mean a departure from normality and outliers (which we know there are some large ones)
3.  Residuals vs. Forest -\> TWS
    -   Possible non-linear effect of Forest -\> TWS
4.  Residuals vs. Recorder Effort
    -   Some heteroscedastcity visible

Therefore, from the diagnostic plots we can conclude that the model validation failed. A possible solution to improve model fit is to log-transform the recorder effort values. These makes sense in the context of our question of turnover and may deal with the large outliers observed in the data.

### (Final)Option 4: GLS with log recorder effort and exponential correlation structure

```{r gls log}
#| label: gls-logged-values
#| echo: false
#| fig-width: 12
#| fig-height: 8
#| fig-cap: "Diagnostic plots for GLS model 2"

# Load model
load(here("data", "models", "gls_model2_all_occurrences_turnover_results.RData"))

# Extract data for plotting
fitted_values_model2 <- fitted(model2_gls)
residuals_norm_model2 <- residuals(model2_gls, type = "normalized")

# Residuals vs Fitted plot
q1 <- ggplot(data.frame(fitted = fitted_values_model2, residuals = residuals_norm_model2), 
             aes(x = fitted, y = residuals)) +
  geom_point(alpha = 0.6, color = "steelblue", size = 1.2) +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed", size = 1) +
  geom_smooth(method = "loess", se = TRUE, color = "darkred", alpha = 0.2) +
  labs(x = "Fitted Values", 
       y = "Normalized Residuals",
       title = "Residuals vs Fitted Values") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# QQ plot
qq_data <- data.frame(theoretical = qqnorm(residuals_norm_model2, plot.it = FALSE)$x,
                      sample = qqnorm(residuals_norm_model2, plot.it = FALSE)$y)

q2 <- ggplot(qq_data, aes(x = theoretical, y = sample)) +
  geom_point(alpha = 0.6, color = "steelblue", size = 1.2) +
  geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed", size = 1) +
  labs(x = "Theoretical Quantiles", 
       y = "Sample Quantiles",
       title = "Normal Q-Q Plot") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))


# Residuals vs Forest to TWS
q3 <- ggplot(data.frame(residuals = residuals_norm_model2), aes(x = residuals)) +
  geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7, color = "white") +
  geom_density(aes(y = after_stat(density) * length(residuals_norm_model2) * (max(residuals_norm_model2) - min(residuals_norm_model2)) / 30), 
               color = "red", size = 1) +
  labs(x = "Normalized Residuals", 
       y = "Frequency",
       title = "Distribution of Residuals") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# Residuals vs Log Recorder Effort
q4 <- ggplot(data.frame(fitted = fitted_values_model2, sqrt_abs_resid = sqrt(abs(residuals_norm_model2))), 
             aes(x = fitted, y = sqrt_abs_resid)) +
  geom_point(alpha = 0.6, color = "steelblue", size = 1.2) +
  geom_smooth(method = "loess", se = TRUE, color = "darkred", alpha = 0.2) +
  labs(x = "Fitted Values", 
       y = "√|Normalized Residuals|",
       title = "Scale-Location Plot") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# Combine plots
gls2_plots <- plot_grid(q1, q2, q3, q4, ncol = 2, labels = c("a)", "b)", "c)", "d)"))

# Dispaly combined plots
gls2_plots

```

The diagnostic plots for this model show that:

1.  Residuals vs Fitted:
    -   Most residuals are centered around 0
    -   Spread is roughly constant across the fitted values
    -   Some slight funneling (i.e. wider spread at lower fitted values) but not extreme
2.  QQ Plot:
    -   There is some deviation from the red line at both tails, suggesting that residuals are not perfectly normal
    -   Our sample size is relatively large, and this is somewhat common with ecological data
3.  Residuals vs. Forest -\> TWS
    -   Possible non-linear effect of Forest -\> TWS or underfitting at very low values
    -   But the majority of residuals look relatively well-centered
4.  Residuals vs. Recorder Effort
    -   Residuals are evenly spread across the range of log recorder effort
    -   Residuals are centered around zero and there is no obvious pattern observed

In conclusion, the model validation showed that log-transforming the recorder effort greatly improved the fit of the model, and this is now good to use. Hooray!
