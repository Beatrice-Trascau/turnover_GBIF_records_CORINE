---
title: "Forest to TWS JDI Data Exploration"
format: html
editor: visual
number-sections: true
crossref:
  fig-title: "Figure"
  tbl-title: "Table"
---

# Aims

This document outlines data exploration steps of the data used to model temporal turnover in land cover cells undergoing the Forest to Transitional Woodland Shrub transition.

```{r libraries}
#| label: packages
#| echo: false
#| include: false

library(here)
source(here("scripts", "0_setup.R"))
```

# All GBIF Occurrences

```{r data preparation}
#| label: data-prep
#| include: false

# Load Turnover data
load(here("data", "derived_data",
          "all_periods_turnover_all_land_cover_chanegs_15km.rda"))

# Select only columns for Forest -> TWS model
turnover_forest_tws_15km <- all_periods_turnover_all_land_cover_chanegs_15km |>
  select(-c('2000-2006_TWS no change', '2000-2006_TWS to Forest',
            '2000-2006_Urban_no_change', '2000-2006_all_to_urban',
            '2006-2012_TWS no change', '2006-2012_TWS to Forest',
            '2006-2012_Urban_no_change', '2006-2012_all_to_urban',
            '2012-2018_TWS no change', '2012-2018_TWS to Forest',
            '2012-2018_Urban_no_change', '2012-2018_all_to_urban')) |>
  # determine which rows belong to which time period
  mutate(forest_no_change = case_when(lc_time_period == "2000-2006" ~ `2000-2006_Forest no change`,
                                      lc_time_period == "2006-2012" ~ `2006-2012_Forest no change`,
                                      lc_time_period == "2012-2018" ~ `2012-2018_Forest no change`,
                                      TRUE ~ NA_real_),
         forest_to_tws = case_when(lc_time_period == "2000-2006" ~ `2000-2006_Forest to TWS`,
                                   lc_time_period == "2006-2012" ~ `2006-2012_Forest to TWS`,
                                   lc_time_period == "2012-2018" ~ `2012-2018_Forest to TWS`,
                                   TRUE ~ NA_real_)) |>
  # remove columns no longer required
  select(-`2000-2006_Forest no change`, -`2006-2012_Forest no change`, 
         -`2012-2018_Forest no change`,-`2000-2006_Forest to TWS`, 
         -`2006-2012_Forest to TWS`, -`2012-2018_Forest to TWS`)

# Transform JDI values for beta regression 

# Get N
N <- nrow(turnover_forest_tws_15km)

# Calculate new JDI values
turnover_forest_tws_15km <- turnover_forest_tws_15km |>
  mutate(JDI_beta = (JDI * (N - 1) + 0.5) / N)

# Prepare data for GLS: remove rows with missing x or y and categorise time periods
turnover_forest_tws_15km_coords_time <- turnover_forest_tws_15km |>
  filter(!is.na(x) & !is.na(y)) |>
  mutate(time_numeric = case_when(lc_time_period == "2000-2006" ~ 1,
                                  lc_time_period == "2006-2012" ~ 2,
                                  lc_time_period == "2012-2018" ~ 3))

# Log transform recorder effort values
turnover_forest_tws_15km_coords_time <- turnover_forest_tws_15km_coords_time |>
  mutate(log_recorder_effort = log(recorder_effort))
```

## Summary Statistics

```{r summary stats}
#| label: tbl-summary-stats
#| echo: false
#| tbl-cap: "Summary Statistics of Jaccard Dissimilarity Index (JDI) by Time Period"

# Extract summary data
summary_by_period <- turnover_forest_tws_15km |>
  group_by(lc_time_period) |>
  summarize(n_observations = n(),
            mean_JDI = mean(JDI, na.rm = TRUE),
            sd_JDI = sd(JDI, na.rm = TRUE),
            mean_forest_to_tws = mean(forest_to_tws, na.rm = TRUE),
            sd_forest_to_tws = sd(forest_to_tws, na.rm = TRUE),
            mean_forest_no_change = mean(forest_no_change, na.rm = TRUE),
            sd_forest_no_change = sd(forest_no_change, na.rm = TRUE),
            mean_delta_recorder_effort = mean(delta_recorder_effort, na.rm = TRUE),
            mean_recorder_effort = mean(recorder_effort, na.rm = TRUE))

# Create table for period summary
summary_period_table <- summary_by_period |>
  kbl(digits = 3,
      align = c("l", rep("r", ncol(summary_by_period)-1))) |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = TRUE) |>
  column_spec(1, bold = TRUE) |>
  row_spec(0, bold = TRUE, background = "#E6F0FF") |>
  add_header_above(c(" " = 1, 
                     "Sample" = 1,
                     "Turnover" = 2, 
                     "Forest to TWS" = 2,
                     "Forest No Change" = 2,
                     "Recorder Effort" = 2))

# Print the table
summary_period_table

```

## Distribution of Variables

Firstly, we look at the distribution of values across each of the response variables used in our model.

```{r variables}
#| label: fig-variables-distributions
#| fig-cap: "Distribution of a) Jaccard Dissimilarity Index, b) Forest to TWS transition pixel count, c) Forest No Change pixel count, d) Recorder Effort e) Change in Recorder Effort"
#| echo: false

# Jaccard's Dissimilarity Index
jdi_hist <- ggplot(turnover_forest_tws_15km, aes(x = JDI)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Jaccard Dissimilarity Index",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Forest -> TWS
forest_to_tws_hist <- ggplot(turnover_forest_tws_15km, aes(x = forest_to_tws)) +
  geom_histogram(bins = 30, fill = "brown", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Forest to TWS Transition (pixel count)",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Forest No Change
forest_no_change_hist <- ggplot(turnover_forest_tws_15km, aes(x = forest_no_change)) +
  geom_histogram(bins = 30, fill = "darkgreen", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Forest No Change (pixel count)",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Recorder effort
recorder_effort_plot <- ggplot(turnover_forest_tws_15km, aes(x = recorder_effort)) +
  geom_histogram(bins = 30, fill = "orange", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Recorder Effort",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Delta recorder effort
delta_recorder_effort_plot <- ggplot(turnover_forest_tws_15km, aes(x = delta_recorder_effort)) +
  geom_histogram(bins = 30, fill = "coral", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Delta Recorder Effort",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Combine plots
plots <- plot_grid(jdi_hist, forest_to_tws_hist, forest_no_change_hist, recorder_effort_plot, delta_recorder_effort_plot, ncol = 2, labels = c("a)", "b)", "c)", "d)", "e)"))

# Print plots
plots
```

## Correlation Matrix

Then, we will also check the correlation between the variables used in the analysis.

```{r variable relationships}
#| label: fig-variables-relationships
#| echo: false
#| fig-cap: "Correlation matrix of variables used in models"
#| fig-width: 6
#| fig-height: 4

# Check if there are any cells with recorder effort = 0
a <- turnover_forest_tws_15km |>
  filter(recorder_effort == 0)
length(a) #0 - Good!

# Log transform recorder effort values
turnover_forest_tws_15km <- turnover_forest_tws_15km |>
  mutate(log_recorder_effort = log(recorder_effort))

# Correlation matrix for numeric variables
numeric_vars <- turnover_forest_tws_15km |>
  select(JDI, forest_to_tws, forest_no_change, 
         intersection_size, union_size, 
         total_spp_before, total_spp_after,
         total_occ_before, total_occ_after,
         recorder_effort, delta_recorder_effort,
         log_recorder_effort)

# Calculate correlation matrix
cor_matrix <- cor(numeric_vars, use = "pairwise.complete.obs")

# Create correlation plot
cor_plot <- corrplot(cor_matrix, 
                     method = "circle", 
                     type = "upper", 
                     tl.col = "black", 
                     tl.srt = 45, 
                     addCoef.col = "black", 
                     number.cex = 0.7,
                     diag = FALSE)
```

Fortunately, we see no concerningly large correlations between variables used in the analysis.

## Outliers

Data exploration revealed that the data contains some large outliers. Outlier summary:

```{r outlier summary}
#| label: outlier-summary
#| echo: false

# Load the Forest -> TWS raster for spatial reference
clc_status_15km_forest_tws_masked <- rast(here("data", "derived_data", 
                                               "clc_status_15km_forest_tws_masked.tif"))

# 1. IDENTIFY OUTLIERS ---------------------------------------------------------

# Calculate quartiles and IQR for forest_to_tws
q1_forest <- quantile(turnover_forest_tws_15km$forest_to_tws, 0.25, na.rm = TRUE)
q3_forest <- quantile(turnover_forest_tws_15km$forest_to_tws, 0.75, na.rm = TRUE)
iqr_forest <- q3_forest - q1_forest
upper_forest <- q3_forest + 1.5 * iqr_forest
lower_forest <- q1_forest - 1.5 * iqr_forest

# Calculate quartiles and IQR for recorder_effort
q1_effort <- quantile(turnover_forest_tws_15km$recorder_effort, 0.25, na.rm = TRUE)
q3_effort <- quantile(turnover_forest_tws_15km$recorder_effort, 0.75, na.rm = TRUE)
iqr_effort <- q3_effort - q1_effort
upper_effort <- q3_effort + 1.5 * iqr_effort
lower_effort <- q1_effort - 1.5 * iqr_effort

# Flag outliers
turnover_forest_tws_15km <- turnover_forest_tws_15km |>
  mutate(forest_outlier = forest_to_tws > upper_forest | forest_to_tws < lower_forest,
         effort_outlier = recorder_effort > upper_effort | recorder_effort < lower_effort,
         any_outlier = forest_outlier | effort_outlier,
         outlier_type = case_when(forest_outlier & effort_outlier ~ "Both",
                                  forest_outlier ~ "Forest->TWS",
                                  effort_outlier ~ "Recorder Effort",
                                  TRUE ~ "None"))

# Print outlier summary
cat("Forest->TWS outliers:", sum(turnover_forest_tws_15km$forest_outlier, na.rm = TRUE), "\n")
cat("Recorder Effort outliers:", sum(turnover_forest_tws_15km$effort_outlier, na.rm = TRUE), "\n")
cat("Total cells with any outlier:", sum(turnover_forest_tws_15km$any_outlier, na.rm = TRUE), "\n")
cat("Forest->TWS threshold:", round(upper_forest, 2), "\n")
cat("Recorder Effort threshold:", round(upper_effort, 2), "\n")
```

The outlier summary showed that there were

```{r outlier interactive map}
#| label: fig-outlier-map
#| echo: false
#| fig-cap: "Map of Recorder Effort and Forest to TWS Outliers across Norway"


# 2. CONVERT TO SPATIAL DATA ---------------------------------------------------

# Convert to sf object for mapping
turnover_sf <- st_as_sf(turnover_forest_tws_15km,
                        coords = c("x", "y"),
                        crs = st_crs(clc_status_15km_forest_tws_masked))

# Transform to WGS84 for leaflet
turnover_sf_wgs84 <- st_transform(turnover_sf, crs = 4326)

# 3. CREATE INTERACTIVE MAPS --------------------------------------------------- 

# Create color palette for forest_to_tws
forest_pal <- colorNumeric(palette = viridis::viridis(100),
                           domain = turnover_sf_wgs84$forest_to_tws,
                           na.color = "transparent")

# Create base map
forest_map <- leaflet() |>
  addProviderTiles("CartoDB.Positron") |>
  setView(lng = 10.7522, lat = 64.1, zoom = 5)

# Add each time period as a separate layer group
for(period in unique(turnover_sf_wgs84$lc_time_period)) {
  period_data <- turnover_sf_wgs84[turnover_sf_wgs84$lc_time_period == period, ]
  
  forest_map <- forest_map |>
    addCircleMarkers(data = period_data, group = period, radius = 3,
                     fillColor = ~forest_pal(forest_to_tws),
                     color = "white", weight = 0.5, opacity = 1,
                     fillOpacity = 0.8, 
                     popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                                     "<b>Period:</b> ", lc_time_period, "<br>",
                                     "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                                     "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                                     "<b>JDI:</b> ", round(JDI, 3), "<br>",
                                     "<b>Outlier Type:</b> ", outlier_type),
                     label = ~paste0("Forest->TWS: ", round(forest_to_tws, 2), " (", lc_time_period, ")"))
}

# Add layer control and legend
forest_map <- forest_map |>
  addLayersControl(overlayGroups = unique(turnover_sf_wgs84$lc_time_period),
                   options = layersControlOptions(collapsed = FALSE)) |>
  addLegend(pal = forest_pal, values = turnover_sf_wgs84$forest_to_tws,
            title = "Forest -> TWS<br>(100m pixels)",position = "bottomright")

# Create colour pallete for recorder effort
effort_pal <- colorNumeric(palette = viridis::plasma(100),
                           domain = turnover_sf_wgs84$recorder_effort,
                           na.color = "transparent")

# Create bse map for recorder effort
effort_map <- leaflet() |>
  addProviderTiles("CartoDB.Positron") |>
  setView(lng = 10.7522, lat = 64.1, zoom = 5)

# Add each time period as a separate layer group
for(period in unique(turnover_sf_wgs84$lc_time_period)) {
  period_data <- turnover_sf_wgs84[turnover_sf_wgs84$lc_time_period == period, ]
  
  effort_map <- effort_map |>
    addCircleMarkers(data = period_data, group = period, radius = 3,
      fillColor = ~effort_pal(recorder_effort), color = "white", weight = 0.5,
      opacity = 1, fillOpacity = 0.8,
      popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                      "<b>Period:</b> ", lc_time_period, "<br>",
                      "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                      "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                      "<b>JDI:</b> ", round(JDI, 3), "<br>",
                      "<b>Outlier Type:</b> ", outlier_type),
      label = ~paste0("Recorder Effort: ", recorder_effort, " (", lc_time_period, ")"))
}

# Add layer control and legend to recorder effort map
effort_map <- effort_map |>
  addLayersControl(overlayGroups = unique(turnover_sf_wgs84$lc_time_period),
                   options = layersControlOptions(collapsed = FALSE)) |>
  addLegend(pal = effort_pal,
            values = turnover_sf_wgs84$recorder_effort,
            title = "Recorder Effort<br>(total occurrences)",
            position = "bottomright")

# Outlier Map with outlier type control 
outlier_colors <- c("Forest->TWS" = "red", 
                    "Recorder Effort" = "blue", 
                    "Both" = "purple",
                    "None" = "lightgrey")

# Add base map for outliers
outlier_map <- leaflet() |>
  addProviderTiles("CartoDB.Positron") |>
  setView(lng = 10.7522, lat = 64.1, zoom = 5)


# Add Forest->TWS outliers as one layer
forest_outliers <- turnover_sf_wgs84[turnover_sf_wgs84$forest_outlier == TRUE, ]
outlier_map <- outlier_map |>
  addCircleMarkers(data = forest_outliers,
                   group = "Forest->TWS Outliers",
                   fillColor = "red",
                   color = "white",
                   weight = 0.5,
                   opacity = 1,
                   fillOpacity = 0.9,
                   popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                                   "<b>Period:</b> ", lc_time_period, "<br>",
                                   "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                                   "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                                   "<b>JDI:</b> ", round(JDI, 3), "<br>",
                                   "<b>Outlier Type:</b> ", outlier_type, "<br>",
                                   "<b>SSB ID:</b> ", ssb_id),
                   label = ~paste0("Forest->TWS Outlier: ", round(forest_to_tws, 2), " (", lc_time_period, ")"))

# Add Recorder Effort outliers as another layer
effort_outliers <- turnover_sf_wgs84[turnover_sf_wgs84$effort_outlier == TRUE, ]
outlier_map <- outlier_map |>
  addCircleMarkers(data = effort_outliers, group = "Recorder Effort Outliers",
                   radius = 5, fillColor = "blue", color = "white", weight = 0.5,
                   opacity = 1, fillOpacity = 0.9,
                   popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                                   "<b>Period:</b> ", lc_time_period, "<br>",
                                   "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                                   "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                                   "<b>JDI:</b> ", round(JDI, 3), "<br>",
                                   "<b>Outlier Type:</b> ", outlier_type, "<br>",
                                   "<b>SSB ID:</b> ", ssb_id),
                   label = ~paste0("Recorder Effort Outlier: ", recorder_effort, " (", lc_time_period, ")"))

# Add cells with both types of outliers
both_outliers <- turnover_sf_wgs84[turnover_sf_wgs84$outlier_type == "Both", ]
outlier_map <- outlier_map |>
  addCircleMarkers(data = both_outliers, group = "Both Types", radius = 6,
                   fillColor = "purple", color = "white", weight = 0.5,
                   opacity = 1, fillOpacity = 0.9,
                   popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                                   "<b>Period:</b> ", lc_time_period, "<br>",
                                   "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                                   "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                                   "<b>JDI:</b> ", round(JDI, 3), "<br>",
                                   "<b>Outlier Type:</b> ", outlier_type, "<br>",
                                   "<b>SSB ID:</b> ", ssb_id),
                   label = ~paste0("Both Outliers (", lc_time_period, ")"))

# Add non-outliers as a background layer (optional, lighter/smaller)
non_outliers <- turnover_sf_wgs84[turnover_sf_wgs84$any_outlier == FALSE, ]
outlier_map <- outlier_map |>
  addCircleMarkers(data = non_outliers, group = "Non-outliers", radius = 1.5,
                   fillColor = "lightgrey", color = "white", weight = 0.3,
                   opacity = 0.7, fillOpacity = 0.3, 
                   popup = ~paste0("<b>Cell ID:</b> ", cell_ID, "<br>",
                                   "<b>Period:</b> ", lc_time_period, "<br>",
                                   "<b>Forest->TWS:</b> ", round(forest_to_tws, 2), "<br>",
                                   "<b>Recorder Effort:</b> ", recorder_effort, "<br>",
                                   "<b>JDI:</b> ", round(JDI, 3), "<br>",
                                   "<b>Outlier Type:</b> ", outlier_type, "<br>",
                                   "<b>SSB ID:</b> ", ssb_id),
                   label = ~paste0("Normal cell (", lc_time_period, ")"))

# Add layer controls for outlier types
outlier_type_map <- outlier_map |>
  addLayersControl(overlayGroups = c("Forest->TWS Outliers", "Recorder Effort Outliers", 
                      "Both Types", "Non-outliers"),
                   options = layersControlOptions(collapsed = FALSE)) |>
  addLegend(colors = c("red", "blue", "purple", "lightgrey"),
            labels = c("Forest->TWS Outliers", "Recorder Effort Outliers", 
               "Both Types", "Non-outliers"),
            title = "Outlier Categories",
            position = "bottomright")

# Print map
outlier_type_map
```

```{r outlier table}
#| label: outlier-summary-table
#| echo: false

# 6. CREATE OUTLIER DATA TABLE ------------------------------------------------

# Create a detailed table of outliers
outlier_table <- turnover_forest_tws_15km |>
  filter(any_outlier) |>
  select(cell_ID, lc_time_period, forest_to_tws, recorder_effort, JDI, 
         outlier_type, ssb_id, x, y) |>
  arrange(desc(forest_to_tws))

# Display interactive table 
DT::datatable(outlier_table, 
              options = list(pageLength = 10, scrollX = TRUE)) |>
  DT::formatRound(columns = c("forest_to_tws", "JDI", "x", "y"), digits = 3)

```

```{r top outliers forest tws}
#| label: tbl-top-outlier-forest-tws
#| echo: false
#| tbl-cap: "Top 10 Forest to TWS Outliers"

# 7. PRINT TOP OUTLIERS -------------------------------------------------------

# Top 10 Forest -> TWS Outliers
top_forest_outliers <- turnover_forest_tws_15km |>
  filter(forest_outlier) |>
  arrange(desc(forest_to_tws)) |>
  slice_head(n = 10) |>
  select(cell_ID, lc_time_period, forest_to_tws, recorder_effort, JDI)

knitr::kable(top_forest_outliers, digits = 3)
```

```{r top outliers recorder effort}
#| label: tbl-top-outlier-recorder-effort
#| echo: false
#| tbl-cap: "Top 10 Recorder Effort Outliers"

# Top 10 Recorder Effort Outliers
top_effort_outliers <- turnover_forest_tws_15km |>
  filter(effort_outlier) |>
  arrange(desc(recorder_effort)) |>
  slice_head(n = 10) |>
  select(cell_ID, lc_time_period, forest_to_tws, recorder_effort, JDI)

knitr::kable(top_effort_outliers, digits = 3)
```

## Modeling

### Trial 1: $\beta$ regression

The models will be run with a $\beta$ distribution. However, since the raw $JDI\in [0,1]$ and the $\beta$ distribution assumes $JDI\in (0,1)$, the JDI values will be transformed according to the formula:

$$\frac{Y*(N-1)+0.5}{N}$$

where Y = the response variable and N = sample size.

For more details on the use of $\beta$ distribution for (0,1) values, see: Beta regression in R. Cibrari-Neto & Zeileis. Journal of Statistical Software. April 2010, Volume 34, Issue 2.

The following $\beta$ regression was run:

```{r beta regression}
#| label: tbl-beta-regression
#| echo: false
#| tbl-cap: "Beta Regression Results Forest->TWS Land Cover Change"

# Load model
load(here("data", "models", "exploratory", 
                 "FTWS_turnover_model1_beta_regression.RData"))

# Extarct residuals from model
model1.1_residuals <- residuals(FTWS_turnover_model1_beta_regression)

# Add residuals to df
turnover_forest_tws_15km$residuals <- model1.1_residuals

# Get summary
model_summary <- tidy(FTWS_turnover_model1_beta_regression,
                      conf.int = TRUE)

# Display summary
knitr::kable(model_summary, digits = 4)
```

```{r beta regression model fit}
#| label: tbl-beta-regression-model-fit
#| echo: false
#| warning: false
#| tbl-cap: "Beta Regression Results Model Fit Statistics"

# Dispaly model fit statistics
model_glance <- glance(FTWS_turnover_model1_beta_regression)
knitr::kable(model_glance, digits = 4)
```

```{r Morans I table}
#| label: tbl-morans-i
#| echo: false
#| tbl-cap: "Moran's I Test for Spatial Autocorrelation of Model Residuals"
#| fig-width: 12
#| fig-height: 8

# 4. CHECK SPATIAL AUTOCORRELATION OF RESIDUALS --------------------------------

## 4.1. Prepare data for testing of autocorrelation ----------------------------

# Create reference grid
reference_grid <- clc_status_15km_forest_tws_masked[[1]]

# Convert turnover df to sf object
turnover_sf <- st_as_sf(turnover_forest_tws_15km,
                        coords = c("x", "y"),
                        crs = st_crs(reference_grid))

## 4.2. Create spatial neighbours ----------------------------------------------

# Create a neighbour list using k-nearest neighbours (k = 5)
coords_matrix <- st_coordinates(turnover_sf)
neighbours <- knn2nb(knearneigh(coords_matrix, k = 5))

# Convert to spatial weights matrix
weights <- nb2listw(neighbours, style = "W")

## 4.3. Calculate Moran's I ----------------------------------------------------

# Compute Moran's I test for spatial autocorrelation
moran_test <- moran.test(turnover_sf$residuals, listw = weights)

# Print results
moran_results <- data.frame(Statistic = c("Moran I", "Expectation", "Variance", "Standard deviate", "P-value"),
                            Value = c(moran_test$estimate[1], 
                                      moran_test$estimate[2], 
                                      moran_test$estimate[3],
                                      moran_test$statistic,
                                      moran_test$p.value))
# Display output
knitr::kable(moran_results, digits = 6,
             col.names = c("Test Statistic", "Value"))

# Create Moran scatterplot to visualise the relationship
# moran_plot <- moran.plot(turnover_sf$residuals, listw = weights,
#                          xlab = "Model Residuals", 
#                          ylab = "Spatially Lagged Residuals")
```

```{r Morans I figure}
#| label: fig-morans-i
#| echo: false
#| fig-cap: "Distribution of a) Local Moran's I, b,c) Significant Spatial Autocorrelation Values"
#| fig-width: 12
#| fig-height: 8

# 5. PLOT MORAN'S I RESULTS ----------------------------------------------------

## 5.1. Calculate local Moran's I values ---------------------------------------

# Calculate local Moran's I wiht zero.policy
local_moran <- localmoran(turnover_sf$residuals, weights, zero.policy = TRUE)

# Add local Moran's I statistics to the spatial dataframe
turnover_sf$local_moran_i <- local_moran[, 1] # I statistics
turnover_sf$local_moran_p <- local_moran[, 5] # p-value

## 5.2. Handle missing values --------------------------------------------------

# Check for missing values in Moran's I column
# missing_values <- sum(is.na(turnover_sf$local_moran_i))
# cat("Number of cells with missing Local Moran's I values:", missing_values, "\n") #0

# Filter out NA for mapping
turnover_sf_clean <- turnover_sf |>
  filter(!is.na(local_moran_i))

## 5.3. Map of local Moran I values --------------------------------------------

# Extract coordinates
coords <- st_coordinates(turnover_sf)
turnover_df <- cbind(st_drop_geometry(turnover_sf), coords)

# Plot map
plot1 <- ggplot(turnover_df |> 
                  filter(!is.na(local_moran_i)), 
                aes(x = X, y = Y, fill = local_moran_i)) +
  geom_tile() +
  scale_fill_viridis_c(option = "viridis", name = "Local Moran's I") +
  theme_classic() +
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank())

# Save map
# ggsave(here("figures", "SupplementaryFigure4a_Local_Moran_I_Forest_TWS_15km.png"),
#        plot1, width = 10, height = 8)


## 5.3. Map of significance of local Moran's I values --------------------------

# Plot map
plot2 <- ggplot(turnover_df |> 
                  filter(!is.na(local_moran_i)), 
                aes(x = X, y = Y, fill = local_moran_p < 0.01)) +
  geom_tile() +
  scale_fill_manual(values = c("TRUE" = "red", "FALSE" = "grey"),
                    name = "Significant",
                    labels = c("FALSE" = "Not significant", "TRUE" = "p < 0.001")) +
  theme_classic() +
  theme(panel.grid = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.line = element_blank(),
          axis.ticks = element_blank())

# Save figure 
# ggsave(here("figures", "SupplementaryFigure4b_Local_Moran_I_Significance_Forest_TWS_15km.png"),
#        plot1, width = 10, height = 8)

## 5.4. Map of significant Moran's I with positive/negative residuals -----------

# Create categorical variable that combines significance and residual sign
turnover_df <- turnover_df |>
  mutate(sig_residual_type = case_when(local_moran_p < 0.01 & residuals > 0 ~ "Significant Positive",
                                       local_moran_p < 0.01 & residuals < 0 ~ "Significant Negative",
                                       local_moran_p >= 0.01 ~ "Not Significant"))

# Plot map of significant clusters with positive/negative residuals
plot3 <- ggplot(turnover_df |>
                  filter(!is.na(local_moran_i)), 
                aes(x = X, y = Y, fill = sig_residual_type)) +
  geom_tile() +
  scale_fill_manual(values = c("Significant Positive" = "pink", 
                               "Significant Negative" = "lightblue",
                               "Not Significant" = "grey"),
                    name = "Residual Type") +
  theme_classic() +
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank())

## 5.5. Combine into single plot -----------------------------------------------

# Combine plots
forest_tws_15km_local_morans_I <- plot_grid(plot1, plot2, plot3,
                                            labels = c("a)", "b)", "c)"),
                                            nrow = 2, align = "h")

# Display plot
forest_tws_15km_local_morans_I

# Save to file
# ggsave(here("figures", "SupplementaryFigure4_Local_Moran_I_Forest_TWS_15km.png"),
#        forest_tws_15km_local_morans_I, width = 18, height = 8)
```

Moran's I test for spatial autocorrelation revealed that there is significant spatial autocorrelation. Therefore, this needs to be accounted for to improve model predictions.

### Trial 2: GLMM with SSB ID as random effect

```{r glmm with ssb}
#| label: glmm-ssb
#| eval: false
#| echo: false

# Load model
load(here("data", "models", "exploratory", 
          "FTWS_turnover_model2_GLMM.RData"))

# Check output
summary(model1.1_mixed) #NaNs
```

The mixed models were attempted with both a 50km x 50km and 250km x 250km SSB ID grid. However, the output for the model was NaN across all estimates.

### Trial 3: Ordered $\beta$

Ordered $\beta$ models allow for $JDI\in [0,1]$, therefore, the values no longer need to be adjusted. This model failed to converge, even when we increased the number of iterations and chains.

### Trial 4: GLS with raw data and exponential correlation structure

General Least Squares (GLS) regression models with an exponential correlation structure around x and y were used. Since some cells are present in the dataframe at different time points, the GLS will interpret them as "duplicates", unless the time is also considered in the correlation structure.

```{r gls raw diagnostics}
#| label: fig-raw-gls
#| echo: false
#| message: false
#| warning: false
#| fig-width: 12
#| fig-height: 8
#| fig-cap: "Diagnostic plots for GLS model 1"

# Load model & data
load(here("data", "models", "exploratory",
                 "FTWS_turnover_model4_gls_raw.RData"))

# Get summary
summary(FTWS_turnover_model4_gls_raw)

# Extract correlation structure parameters
print(FTWS_turnover_model4_gls_raw$modelStruct$corStruct)

# Get range parameter
range_param <- coef(FTWS_turnover_model4_gls_raw$modelStruct$corStruct, unconstrained = FALSE)

# Extract data for plotting
fitted_values <- fitted(FTWS_turnover_model4_gls_raw)
residuals_norm <- residuals(FTWS_turnover_model4_gls_raw, type = "normalized")


# Residuals vs Fitted plot
p1 <- ggplot(data.frame(fitted = fitted_values, residuals = residuals_norm), 
             aes(x = fitted, y = residuals)) +
  geom_point(alpha = 0.6, color = "steelblue", size = 1.2) +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed", size = 1) +
  geom_smooth(method = "loess", se = TRUE, color = "darkred", alpha = 0.2) +
  labs(x = "Fitted Values", 
       y = "Normalized Residuals",
       title = "Residuals vs Fitted Values") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# QQ plot
qq_data <- data.frame(theoretical = qqnorm(residuals_norm, plot.it = FALSE)$x,
                      sample = qqnorm(residuals_norm, plot.it = FALSE)$y)

p2 <- ggplot(qq_data, aes(x = theoretical, y = sample)) +
  geom_point(alpha = 0.6, color = "steelblue", size = 1.2) +
  geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed", size = 1) +
  labs(x = "Theoretical Quantiles", 
       y = "Sample Quantiles",
       title = "Normal Q-Q Plot") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# Residuals vs Forest to TWS
p3 <- ggplot(data.frame(residuals = residuals_norm), aes(x = residuals)) +
  geom_histogram(bins = 30, fill = "steelblue", alpha = 0.7, color = "white") +
  geom_density(aes(y = after_stat(density) * length(residuals_norm) * (max(residuals_norm) - min(residuals_norm)) / 30), 
               color = "red", size = 1) +
  labs(x = "Normalized Residuals", 
       y = "Frequency",
       title = "Distribution of Residuals") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# Residuals vs Recorder Effort
p4 <- ggplot(data.frame(fitted = fitted_values, sqrt_abs_resid = sqrt(abs(residuals_norm))), 
             aes(x = fitted, y = sqrt_abs_resid)) +
  geom_point(alpha = 0.6, color = "steelblue", size = 1.2) +
  geom_smooth(method = "loess", se = TRUE, color = "darkred", alpha = 0.2) +
  labs(x = "Fitted Values", 
       y = "√|Normalized Residuals|",
       title = "Scale-Location Plot") +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

# Combine plots
gls1_plots <- plot_grid(p1, p2, p3, p4, ncol = 2, labels = c("a)", "b)", "c)", "d)"))

# Dispaly combined plots
gls1_plots
```

Inspection of the diagnostic plots revealed that:

1.  Residuals vs Fitted:
    -   Most residuals are centered around 0
    -   But there is an uneven spread of residuals, with larger variance at higher fitted values
    -   There is a clustered pattern around 0.8-0.9 fitted values
    -   All of this suggests that there is some non-constant variance (i.e. hereoscedasticity) and possibly some non-linearity
2.  QQ Plot:
    -   The points mostly follow red line but depart from it at both ends
    -   This might mean a departure from normality and outliers (which we know there are some large ones)
3.  Residuals vs. Forest -\> TWS
    -   Possible non-linear effect of Forest -\> TWS
4.  Residuals vs. Recorder Effort
    -   Some heteroscedastcity visible

Therefore, from the diagnostic plots we can conclude that the model validation failed. A possible solution to improve model fit is to log-transform the recorder effort values. These makes sense in the context of our question of turnover and may deal with the large outliers observed in the data.

### (Final)Trial 5: GLS with log recorder effort and exponential correlation structure

```{r gls log correlation}
#| label: gls-logged-corr-structure
#| echo: false
#| message: false

# Load model
load(here("data", "models", "final",
                 "FTWS_turnover_model5_gls_log.RData"))

# Extract correlation structure parameters
print(FTWS_turnover_model5_gls_log$modelStruct$corStruct)

# Get range parameter
range_param <- coef(FTWS_turnover_model5_gls_log$modelStruct$corStruct, unconstrained = FALSE)
```

```{r gls log}
#| label: fig-gls-logged-values
#| echo: false
#| message: false
#| fig-width: 12
#| fig-height: 8
#| fig-cap: "Diagnostic plots for GLS model 2"


# Extract residuals
residuals_gls <- residuals(FTWS_turnover_model5_gls_log, type = "normalized")

# Get the model frame to ensure we're using the exact same data
model_data <- getData(FTWS_turnover_model5_gls_log)

# Basic residual plots
par(mfrow = c(2, 2))

# Residuals vs fitted
plot(fitted(FTWS_turnover_model5_gls_log), residuals_gls,
     xlab = "Fitted Values", ylab = "Normalized Residuals",
     main = "Residuals vs Fitted")
abline(h = 0, col = "red", lty = 2)

# QQ plot
qqnorm(residuals_gls, main = "Normal Q-Q Plot")
qqline(residuals_gls, col = "red")

# Residuals vs predictors
plot(model_data$forest_to_tws, residuals_gls,
     xlab = "Forest to TWS", ylab = "Normalized Residuals",
     main = "Residuals vs Forest to TWS")
abline(h = 0, col = "red", lty = 2)

plot(model_data$log_recorder_effort, residuals_gls,
     xlab = "Recorder Effort", ylab = "Normalized Residuals",
     main = "Residuals vs Recorder Effort")
abline(h = 0, col = "red", lty = 2)

```

The diagnostic plots for this model show that:

1.  Residuals vs Fitted:
    -   Most residuals are centered around 0
    -   Spread is roughly constant across the fitted values
    -   Some slight funneling (i.e. wider spread at lower fitted values) but not extreme
2.  QQ Plot:
    -   There is some deviation from the red line at both tails, suggesting that residuals are not perfectly normal
    -   Our sample size is relatively large, and this is somewhat common with ecological data
3.  Residuals vs. Forest -\> TWS
    -   Possible non-linear effect of Forest -\> TWS or underfitting at very low values
    -   But the majority of residuals look relatively well-centered
4.  Residuals vs. Recorder Effort
    -   Residuals are evenly spread across the range of log recorder effort
    -   Residuals are centered around zero and there is no obvious pattern observed

In conclusion, the model validation showed that log-transforming the recorder effort greatly improved the fit of the model, and this is now good to use. Hooray!

```{r gls summary}
#| label: tbl-gls-logged-values-summary
#| echo: false
#| tbl-cap: "GLS Model Coefficients Forest → TWS Effects on Biodiversity Turnover"

# Extract model summary
model_summary <- summary(FTWS_turnover_model5_gls_log)
coef_table <- model_summary$tTable

# Create coefficient table without confidence intervals initially
model_coefs <- data.frame(Variable = rownames(coef_table),
                          Estimate = round(coef_table[, "Value"], 4),
                          `Std Error` = round(coef_table[, "Std.Error"], 4),
                          `t value` = round(coef_table[, "t-value"], 3),
                          `p value` = coef_table[, "p-value"],
                          check.names = FALSE)

# Add significance stars
model_coefs$Significance <- case_when(model_coefs$`p value` < 0.001 ~ "***",
                                      model_coefs$`p value` < 0.01 ~ "**", 
                                      model_coefs$`p value` < 0.05 ~ "*",
                                      model_coefs$`p value` < 0.1 ~ ".",
                                      TRUE ~ "")

# Display using kable
knitr::kable(model_coefs, digits = c(0, 4, 4, 3, 6, 0),
             format.args = list(scientific = FALSE))
```

```{r gls2 model fit statistics}
#| label: tbl-gls-model-fit
#| echo: false
#| tbl-cap: "GLS Model Fit Statistics"


# Model information
cat("Model Specifications:\n")
cat("- Formula:", deparse(FTWS_turnover_model5_gls_log$call$model), "\n")
cat("- Correlation Structure: Exponential spatial correlation\n") 
cat("- Method: REML\n")

# Try to get sample size safely
n_obs <- tryCatch({model_summary$dims$N
}, error = function(e) {
  nobs(FTWS_turnover_model5_gls_log)
})

cat("- Number of observations:", n_obs, "\n")

# Model fit statistics
fit_stats <- data.frame(Statistic = c("AIC", "BIC", "Log-likelihood", "Residual Std Error"),
                        Value = c(round(AIC(FTWS_turnover_model5_gls_log), 2),
                                  round(BIC(FTWS_turnover_model5_gls_log), 2), 
                                  round(as.numeric(logLik(FTWS_turnover_model5_gls_log)), 2),
                                  round(model_summary$sigma, 4)))
knitr::kable(fit_stats, col.names = c("Statistic", "Value"))
```

```{r gls model output plot}
#| label: fig-gls-coefficient-plot
#| echo: false
#| message: false
#| warning: false
#| fig-width: 6
#| fig-height: 4
#| fig-cap: "Coefficient Estimates from GLS"

# Get summary of the model
model_summary <- summary(FTWS_turnover_model5_gls_log)

# Create dataframe of coeficients
FTWS_turnover_model5_gls_log_coef_df <- data.frame(term = names(model_summary$tTable[, "Value"]),
                                                   estimate = model_summary$tTable[, "Value"],
                                                   std.error = model_summary$tTable[, "Std.Error"],
                                                   statistic = model_summary$tTable[, "t-value"],
                                                   p.value = model_summary$tTable[, "p-value"])

# Remove the intercept
FTWS_turnover_model5_gls_log_coef_df_no_intercept <- FTWS_turnover_model5_gls_log_coef_df[FTWS_turnover_model5_gls_log_coef_df$term != "(Intercept)", ]

# Create coefficient plot
figure6_a <- ggplot(FTWS_turnover_model5_gls_log_coef_df_no_intercept, aes(x = estimate, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = estimate - 1.96 * std.error,
                     xmax = estimate + 1.96 * std.error)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  scale_y_discrete(labels = c("forest_to_tws" = "Forest to TWS",
                              "forest_no_change" = "Forest No Change", 
                              "delta_recorder_effort" = "ΔRecorder Effort",
                              "log_recorder_effort" = "log Recorder Effort",
                              "lc_time_period2006-2012" = "2006-2012 Time Period",
                              "lc_time_period2012-2018" = "2012-2018 Time Period"),
                   limits = c("lc_time_period2012-2018",
                              "lc_time_period2006-2012", 
                              "log_recorder_effort",
                              "delta_recorder_effort",
                              "forest_no_change",
                              "forest_to_tws")) +
  labs(x = "Estimate ± 95% CI", y = NULL) +
  theme_classic()

# Display plot
figure6_a
```

## Trial 6: GAM with $\Delta$ recorder_effort

Although the model in Trial 5 looked good enough to use, I ran a GAM to check if the fit would be even better.

```{r GAM with recorder effort}
#| label: gam-recorder-effort
#| eval: false
#| echo: false

# Load model
here("data", "models", "exploratory",
                 "FTWS_turnover_model6_GAM.RData")

# Check output
summary(model5_gam)

# Check model fit
par(mfrow = c(2, 2))
gam.check(model5_gam)
```

# Vascular Plant Occurrences

```{r prepare vascular plant data}
#| label: plant-data-prep
#| include: false

# Load Turnover data
load(here("data", "derived_data", 
          "vascular_plants_all_periods_turnover_all_land_cover_chanegs_15km.rda"))

# Select only columns for Forest -> TWS model
plants_turnover_forest_tws_15km <- vascular_plants_all_periods_turnover_all_land_cover_chanegs_15km |>
  select(-c('2000-2006_TWS no change', '2000-2006_TWS to Forest',
            '2000-2006_Urban_no_change', '2000-2006_all_to_urban',
            '2006-2012_TWS no change', '2006-2012_TWS to Forest',
            '2006-2012_Urban_no_change', '2006-2012_all_to_urban',
            '2012-2018_TWS no change', '2012-2018_TWS to Forest',
            '2012-2018_Urban_no_change', '2012-2018_all_to_urban')) |>
  # determine which rows belong to which time period
  mutate(forest_no_change = case_when(lc_time_period == "2000-2006" ~ `2000-2006_Forest no change`,
                                      lc_time_period == "2006-2012" ~ `2006-2012_Forest no change`,
                                      lc_time_period == "2012-2018" ~ `2012-2018_Forest no change`,
                                      TRUE ~ NA_real_),
         forest_to_tws = case_when(lc_time_period == "2000-2006" ~ `2000-2006_Forest to TWS`,
                                   lc_time_period == "2006-2012" ~ `2006-2012_Forest to TWS`,
                                   lc_time_period == "2012-2018" ~ `2012-2018_Forest to TWS`,
                                   TRUE ~ NA_real_)) |>
  # remove columns no longer required
  select(-`2000-2006_Forest no change`, -`2006-2012_Forest no change`, 
         -`2012-2018_Forest no change`,-`2000-2006_Forest to TWS`, 
         -`2006-2012_Forest to TWS`, -`2012-2018_Forest to TWS`)

# Remove rows that might have NA for x or y and categorise time periods for GLS
plants_turnover_forest_tws_15km_coords_time <- plants_turnover_forest_tws_15km |>
  filter(!is.na(x) & !is.na(y)) |>
  mutate(time_numeric = case_when(lc_time_period == "2000-2006" ~ 1,
                                  lc_time_period == "2006-2012" ~ 2,
                                  lc_time_period == "2012-2018" ~ 3))

# Log transform recorder effort values
plants_turnover_forest_tws_15km_coords_time <- plants_turnover_forest_tws_15km_coords_time |>
  mutate(log_recorder_effort = log(recorder_effort))
```

## Summary Statistics

```{r plant-summary-stats}
#| label: tbl-summary-stats-plants
#| echo: false
#| tbl-cap: "Summary Statistics of Jaccard Dissimilarity Index (JDI) by Time Period for Vascular Plant Records"

# Extract summary data
plant_summary_by_period <- plants_turnover_forest_tws_15km |>
  group_by(lc_time_period) |>
  summarize(n_observations = n(),
            mean_JDI = mean(JDI, na.rm = TRUE),
            sd_JDI = sd(JDI, na.rm = TRUE),
            mean_forest_to_tws = mean(forest_to_tws, na.rm = TRUE),
            sd_forest_to_tws = sd(forest_to_tws, na.rm = TRUE),
            mean_forest_no_change = mean(forest_no_change, na.rm = TRUE),
            sd_forest_no_change = sd(forest_no_change, na.rm = TRUE),
            mean_delta_recorder_effort = mean(delta_recorder_effort, na.rm = TRUE),
            mean_recorder_effort = mean(recorder_effort, na.rm = TRUE))

# Create table for period summary
plant_summary_by_period <- plant_summary_by_period |>
  kbl(digits = 3,
      align = c("l", rep("r", ncol(plant_summary_by_period)-1))) |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = TRUE) |>
  column_spec(1, bold = TRUE) |>
  row_spec(0, bold = TRUE, background = "#E6F0FF") |>
  add_header_above(c(" " = 1, 
                     "Sample" = 1,
                     "Turnover" = 2, 
                     "Forest to TWS" = 2,
                     "Forest No Change" = 2,
                     "Recorder Effort" = 2))

# Print the table
plant_summary_by_period
```

## Distribution of Values

```{r plant-variables}
#| label: fig-variables-distributions-plant
#| fig-cap: "Distribution of a) Jaccard Dissimilarity Index, b) Forest to TWS transition pixel count, c) Forest No Change pixel count, d) Recorder Effort e) Change in Recorder Effort in Subser with Only Vascular Plant Records"
#| echo: false

# Jaccard's Dissimilarity Index
plant_jdi_hist <- ggplot(plants_turnover_forest_tws_15km, aes(x = JDI)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Jaccard Dissimilarity Index",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Forest -> TWS
plant_forest_to_tws_hist <- ggplot(plants_turnover_forest_tws_15km, aes(x = forest_to_tws)) +
  geom_histogram(bins = 30, fill = "brown", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Forest to TWS Transition (pixel count)",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Forest No Change
plant_forest_no_change_hist <- ggplot(plants_turnover_forest_tws_15km, aes(x = forest_no_change)) +
  geom_histogram(bins = 30, fill = "darkgreen", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Forest No Change (pixel count)",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Recorder effort
plant_recorder_effort_plot <- ggplot(plants_turnover_forest_tws_15km, aes(x = recorder_effort)) +
  geom_histogram(bins = 30, fill = "orange", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Recorder Effort",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Delta recorder effort
plant_delta_recorder_effort_plot <- ggplot(plants_turnover_forest_tws_15km, aes(x = delta_recorder_effort)) +
  geom_histogram(bins = 30, fill = "coral", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Delta Recorder Effort",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Combine plots
plant_plots <- plot_grid(plant_jdi_hist, plant_forest_to_tws_hist, plant_forest_no_change_hist, plant_recorder_effort_plot, plant_delta_recorder_effort_plot, ncol = 2, labels = c("a)", "b)", "c)", "d)", "e)"))

# Print plots
plant_plots
```

## Correlation Matrix

```{r plant correlation matrix}
#| label: fig-variables-relationships-plants
#| echo: false
#| fig-cap: "Correlation matrix of variables used in the vascular plant models"
#| fig-width: 6
#| fig-height: 4

# Check if there are any cells with recorder effort = 0
b <- plants_turnover_forest_tws_15km |>
  filter(recorder_effort == 0)
length(b) #0 - Good!

# Log transform recorder effort values
plants_turnover_forest_tws_15km <- plants_turnover_forest_tws_15km |>
  mutate(log_recorder_effort = log(recorder_effort))

# Correlation matrix for numeric variables
plant_numeric_vars <- plants_turnover_forest_tws_15km |>
  select(JDI, forest_to_tws, forest_no_change, 
         intersection_size, union_size, 
         total_spp_before, total_spp_after,
         total_occ_before, total_occ_after,
         recorder_effort, delta_recorder_effort,
         log_recorder_effort)

# Calculate correlation matrix
plant_cor_matrix <- cor(plant_numeric_vars, use = "pairwise.complete.obs")

# Create correlation plot
plant_cor_plot <- corrplot(plant_cor_matrix, 
                     method = "circle", 
                     type = "upper", 
                     tl.col = "black", 
                     tl.srt = 45, 
                     addCoef.col = "black", 
                     number.cex = 0.7,
                     diag = FALSE)
```

## Modeling

### (Final) Trial1: GLS

```{r gls plants}
#| label: fig-gls-plants
#| echo: false
#| message: false

# Load model
load(here("data", "models", "final", "plants_FTWS_model1_gls.RData"))

# Extract correlation structure parameters
print(plants_FTWS_model1_gls$modelStruct$corStruct)

# Get range parameter
range_param <- coef(plants_FTWS_model1_gls$modelStruct$corStruct, unconstrained = FALSE)

# Get summary
plants_FTWS_model1_gls_summary <- summary(plants_FTWS_model1_gls)
```

A GLS with the same set-up and parameters as the one in Option 4 was run for the sub-set of data containing only vascular plant occurrences.

```{r plant gls output}
#| label: fig-plant-gls-output
#| echo: false
#| message: false
#| fig-width: 12
#| fig-height: 8
#| fig-cap: "Diagnostic plots for GLS model for vascular plant occurrences"

# Extract residuals
plant_residuals_gls <- residuals(plants_FTWS_model1_gls, type = "normalized")

# Get the data actually used in the model
plants_model_data <- getData(plants_FTWS_model1_gls)

# Basic residual plots
par(mfrow = c(2, 2))

# Residuals vs fitted
plot(fitted(plants_FTWS_model1_gls), plant_residuals_gls,
     xlab = "Fitted Values", ylab = "Normalized Residuals",
     main = "Residuals vs Fitted")
abline(h = 0, col = "red", lty = 2)

# QQ plot
qqnorm(plant_residuals_gls, main = "Normal Q-Q Plot")
qqline(plant_residuals_gls, col = "red")

# Residuals vs predictors
plot(plants_model_data$forest_to_tws, plant_residuals_gls,
     xlab = "Forest to TWS", ylab = "Normalized Residuals",
     main = "Residuals vs Forest to TWS")
abline(h = 0, col = "red", lty = 2)

plot(plants_model_data$log_recorder_effort, plant_residuals_gls,
     xlab = "Recorder Effort", ylab = "Normalized Residuals",
     main = "Residuals vs Recorder Effort")
abline(h = 0, col = "red", lty = 2)
```

Inspecting the diagnostic plots, we can conclude the following:

1.  Residuals vs Fitted
    -   There is a some curving, with residuals becoming more negative with increasing fitted values, which suggests a non-linear relationship
2.  QQ plot
    -   Residuals deviate slightly from the line at both ends, but no wild behaviour
3.  Residuals vs Forest to TWS
    -   Clumping at low values, which is expected if many cells have little or no change (which is the case for us)
    -   No clear trend
4.  Residuals vs Recorder Effort
    -   Relatively even spread
    -   No clear pattern

The issue of the funneling in the Residuals vs Fitted plot is the more concerning one. We have tried several other models to explore how they would perform. However, for the sake of keeping all turnover analyses consistent, we chose to use the output of this model.

```{r gls plants summary}
#| label: tbl-gls-plantss-summary
#| echo: false
#| tbl-cap: "GLS Model Coefficients Forest → TWS Effects on Vascular Plant Turnover"

# Create coefficient table
coef_table_plants <- plants_FTWS_model1_gls_summary$tTable

# Create coefficient table without confidence intervals initially
model_coefs_plants <- data.frame(Variable = rownames(coef_table_plants),
                          Estimate = round(coef_table_plants[, "Value"], 4),
                          `Std Error` = round(coef_table_plants[, "Std.Error"], 4),
                          `t value` = round(coef_table_plants[, "t-value"], 3),
                          `p value` = coef_table_plants[, "p-value"],
                          check.names = FALSE)

# Add significance stars
model_coefs_plants$Significance <- case_when(model_coefs_plants$`p value` < 0.001 ~ "***",
                                      model_coefs_plants$`p value` < 0.01 ~ "**", 
                                      model_coefs_plants$`p value` < 0.05 ~ "*",
                                      model_coefs_plants$`p value` < 0.1 ~ ".",
                                      TRUE ~ "")

# Display using kable
knitr::kable(model_coefs_plants, digits = c(0, 4, 4, 3, 6, 0),
             format.args = list(scientific = FALSE))
```

```{r gls plants model fit statistics}
#| label: tbl-gls-plants-model-fit
#| echo: false
#| tbl-cap: "GLS Plants Model Fit Statistics"


# Model information
cat("Model Specifications:\n")
cat("- Formula:", deparse(plants_FTWS_model1_gls$call$model), "\n")
cat("- Correlation Structure: Exponential spatial correlation\n") 
cat("- Method: REML\n")

# Try to get sample size safely
n_obs <- tryCatch({plants_FTWS_model1_gls_summary$dims$N
}, error = function(e) {
  nobs(plants_FTWS_model1_gls)
})

cat("- Number of observations:", n_obs, "\n")

# Model fit statistics
fit_stats <- data.frame(Statistic = c("AIC", "BIC", "Log-likelihood", "Residual Std Error"),
                        Value = c(round(AIC(plants_FTWS_model1_gls), 2),
                                  round(BIC(plants_FTWS_model1_gls), 2), 
                                  round(as.numeric(logLik(plants_FTWS_model1_gls)), 2),
                                  round(plants_FTWS_model1_gls_summary$sigma, 4)))
knitr::kable(fit_stats, col.names = c("Statistic", "Value"))
```

```{r gls plants model output plot}
#| label: fig-gls-plants-coefficient-plot
#| echo: false
#| message: false
#| warning: false
#| fig-width: 6
#| fig-height: 4
#| fig-cap: "Coefficient Estimates from Vascular Plants GLS"

# Create dataframe of coeficients
plants_FTWS_model1_gls_coef_df <- data.frame(term = names(plants_FTWS_model1_gls_summary$tTable[, "Value"]),
                                             estimate = plants_FTWS_model1_gls_summary$tTable[, "Value"],
                                                   std.error = plants_FTWS_model1_gls_summary$tTable[, "Std.Error"],
                                                   statistic = plants_FTWS_model1_gls_summary$tTable[, "t-value"],
                                                   p.value = plants_FTWS_model1_gls_summary$tTable[, "p-value"])

# Remove the intercept
plants_FTWS_model1_gls_coef_df_no_intercept <- plants_FTWS_model1_gls_coef_df[plants_FTWS_model1_gls_coef_df$term != "(Intercept)", ]

# Create coefficient plot
figure6_b <- ggplot(plants_FTWS_model1_gls_coef_df_no_intercept, aes(x = estimate, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = estimate - 1.96 * std.error,
                     xmax = estimate + 1.96 * std.error)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  scale_y_discrete(labels = c("forest_to_tws" = "Forest to TWS",
                              "forest_no_change" = "Forest No Change", 
                              "delta_recorder_effort" = "ΔRecorder Effort",
                              "log_recorder_effort" = "log Recorder Effort",
                              "lc_time_period2006-2012" = "2006-2012 Time Period",
                              "lc_time_period2012-2018" = "2012-2018 Time Period"),
                   limits = c("lc_time_period2012-2018",
                              "lc_time_period2006-2012", 
                              "log_recorder_effort",
                              "delta_recorder_effort",
                              "forest_no_change",
                              "forest_to_tws")) +
  labs(x = "Estimate ± 95% CI", y = NULL) +
  theme_classic()

# Display plot
figure6_b
```

### Trial 2: GAM with spatial smoother

```{r plants gam1}
#| label: fig-plants-gam-check
#| echo: false
#| message: false
#| fig-width: 12
#| fig-height: 8
#| fig-cap: "Diagnostic plots for GAM model for vascular plant occurrences"

# Load model
load(here("data", "models", "exploratory", "plants_FTWS_model2_GAM.RData"))

# Check model summary
summary(plants_FTWS_model2_GAM)

# Diagnostic plots
par(mfrow = c(2, 2))
gam.check(plants_FTWS_model2_GAM)
```

The diagnostic plots reveal some deviances from expectations which might prove problematic. Since there is some curvature to the relationship between residuals and Forest to TWS, I will also try a model that fits a smoother around that variable.

### Option 3: GAM with Forest -\> TWS and spatial smoother

```{r plants gam2}
#| label: fig-plants-gam2-check
#| echo: false
#| message: false
#| fig-width: 12
#| fig-height: 8
#| fig-cap: "Diagnostic plots for second GAM model for vascular plant occurrences"

# Load model
load(here("data", "models", "exploratory", "plants_FTWS_model3_GAM_extra_smooth.RData"))

# Extract summary
summary(plants_FTWS_model3_GAM_extra_smooth)

# Diagnostic plots
par(mfrow = c(2, 2))
gam.check(plants_FTWS_model3_GAM_extra_smooth)
```

# Bird Occurrences

```{r prepare bird data}
#| label: bird-data-prep
#| include: false

# Load data
load(here("data", "derived_data", 
          "birds_all_periods_turnover_all_land_cover_chanegs_15km.rda"))

# Select only columns for Forest -> TWS model
birds_turnover_forest_tws_15km <- birds_all_periods_turnover_all_land_cover_chanegs_15km |>
  select(-c('2000-2006_TWS no change', '2000-2006_TWS to Forest',
            '2000-2006_Urban_no_change', '2000-2006_all_to_urban',
            '2006-2012_TWS no change', '2006-2012_TWS to Forest',
            '2006-2012_Urban_no_change', '2006-2012_all_to_urban',
            '2012-2018_TWS no change', '2012-2018_TWS to Forest',
            '2012-2018_Urban_no_change', '2012-2018_all_to_urban')) |>
  # determine which rows belong to which time period
  mutate(forest_no_change = case_when(lc_time_period == "2000-2006" ~ `2000-2006_Forest no change`,
                                      lc_time_period == "2006-2012" ~ `2006-2012_Forest no change`,
                                      lc_time_period == "2012-2018" ~ `2012-2018_Forest no change`,
                                      TRUE ~ NA_real_),
         forest_to_tws = case_when(lc_time_period == "2000-2006" ~ `2000-2006_Forest to TWS`,
                                   lc_time_period == "2006-2012" ~ `2006-2012_Forest to TWS`,
                                   lc_time_period == "2012-2018" ~ `2012-2018_Forest to TWS`,
                                   TRUE ~ NA_real_)) |>
  # remove columns no longer required
  select(-`2000-2006_Forest no change`, -`2006-2012_Forest no change`, 
         -`2012-2018_Forest no change`,-`2000-2006_Forest to TWS`, 
         -`2006-2012_Forest to TWS`, -`2012-2018_Forest to TWS`)

# Remove rows that might have NA for x or y & categorise time periods
birds_turnover_forest_tws_15km_coords_time <- birds_turnover_forest_tws_15km |>
  filter(!is.na(x) & !is.na(y)) |>
  mutate(time_numeric = case_when(lc_time_period == "2000-2006" ~ 1,
                                  lc_time_period == "2006-2012" ~ 2,
                                  lc_time_period == "2012-2018" ~ 3))

# Log transform recorder effort values
birds_turnover_forest_tws_15km_coords_time <- birds_turnover_forest_tws_15km_coords_time |>
  mutate(log_recorder_effort = log(recorder_effort))
```

## Summary Statistics

```{r bird summary statistics}
#| label: tbl-summary-stats-birds
#| echo: false
#| tbl-cap: "Summary Statistics of Jaccard Dissimilarity Index (JDI) by Time Period for Bird Records"

# Extract summary data
birds_summary_by_period <- birds_turnover_forest_tws_15km |>
  group_by(lc_time_period) |>
  summarize(n_observations = n(),
            mean_JDI = mean(JDI, na.rm = TRUE),
            sd_JDI = sd(JDI, na.rm = TRUE),
            mean_forest_to_tws = mean(forest_to_tws, na.rm = TRUE),
            sd_forest_to_tws = sd(forest_to_tws, na.rm = TRUE),
            mean_forest_no_change = mean(forest_no_change, na.rm = TRUE),
            sd_forest_no_change = sd(forest_no_change, na.rm = TRUE),
            mean_delta_recorder_effort = mean(delta_recorder_effort, na.rm = TRUE),
            mean_recorder_effort = mean(recorder_effort, na.rm = TRUE))

# Create table for period summary
birds_summary_by_period <- birds_summary_by_period |>
  kbl(digits = 3,
      align = c("l", rep("r", ncol(birds_summary_by_period)-1))) |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = TRUE) |>
  column_spec(1, bold = TRUE) |>
  row_spec(0, bold = TRUE, background = "#E6F0FF") |>
  add_header_above(c(" " = 1, 
                     "Sample" = 1,
                     "Turnover" = 2, 
                     "Forest to TWS" = 2,
                     "Forest No Change" = 2,
                     "Recorder Effort" = 2))

# Print the table
birds_summary_by_period
```

## Distribution of Values

```{r bird values}
#| label: fig-variables-distributions-birds
#| fig-cap: "Distribution of a) Jaccard Dissimilarity Index, b) Forest to TWS transition pixel count, c) Forest No Change pixel count, d) Recorder Effort e) Change in Recorder Effort in Subser with Only Bird Records"
#| echo: false

# Jaccard's Dissimilarity Index
bird_jdi_hist <- ggplot(birds_turnover_forest_tws_15km, aes(x = JDI)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Jaccard Dissimilarity Index",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Forest -> TWS
bird_forest_to_tws_hist <- ggplot(birds_turnover_forest_tws_15km, aes(x = forest_to_tws)) +
  geom_histogram(bins = 30, fill = "brown", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Forest to TWS Transition (pixel count)",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Forest No Change
bird_forest_no_change_hist <- ggplot(birds_turnover_forest_tws_15km, aes(x = forest_no_change)) +
  geom_histogram(bins = 30, fill = "darkgreen", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Forest No Change (pixel count)",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Recorder effort
bird_recorder_effort_plot <- ggplot(birds_turnover_forest_tws_15km, aes(x = recorder_effort)) +
  geom_histogram(bins = 30, fill = "orange", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Recorder Effort",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Delta recorder effort
bird_delta_recorder_effort_plot <- ggplot(birds_turnover_forest_tws_15km, aes(x = delta_recorder_effort)) +
  geom_histogram(bins = 30, fill = "coral", color = "white", alpha = 0.7) +
  facet_wrap(~ lc_time_period) +
  labs(x = "Delta Recorder Effort",
       y = "Count") +
  theme_classic() +
  theme(strip.background = element_rect(fill = "lightgrey"),
        strip.text = element_text(face = "bold"))

# Combine plots
bird_plots <- plot_grid(bird_jdi_hist, bird_forest_to_tws_hist, bird_forest_no_change_hist, bird_recorder_effort_plot, bird_delta_recorder_effort_plot, ncol = 2, labels = c("a)", "b)", "c)", "d)", "e)"))

# Print plots
bird_plots
```

## Correlation Matrix

```{r bird correlation matrix}
#| label: fig-variables-relationships-birds
#| echo: false
#| fig-cap: "Correlation matrix of variables used in the bird models"
#| fig-width: 6
#| fig-height: 4

# Check if there are any cells with recorder effort = 0
c <- birds_turnover_forest_tws_15km |>
  filter(recorder_effort == 0)
length(c) #0 - Good!

# Log transform recorder effort values
birds_turnover_forest_tws_15km <- birds_turnover_forest_tws_15km |>
  mutate(log_recorder_effort = log(recorder_effort))


# Correlation matrix for numeric variables
bird_numeric_vars <- birds_turnover_forest_tws_15km |>
  select(JDI, forest_to_tws, forest_no_change, 
         intersection_size, union_size, 
         total_spp_before, total_spp_after,
         total_occ_before, total_occ_after,
         recorder_effort, delta_recorder_effort,
         log_recorder_effort)

# Calculate correlation matrix
bird_cor_matrix <- cor(bird_numeric_vars, use = "pairwise.complete.obs")

# Create correlation plot
bird_cor_plot <- corrplot(bird_cor_matrix, 
                     method = "circle", 
                     type = "upper", 
                     tl.col = "black", 
                     tl.srt = 45, 
                     addCoef.col = "black", 
                     number.cex = 0.7,
                     diag = FALSE)
```

## Modeling

### (Final) Trial 1: GLS

```{r bird gls}
#| label: bird-gls-output
#| echo: false
#| message: false

# Load model
load(here("data", "models", "exploratory", "birds_FTWS_model1_gls.RData"))

# Extract summary
birds_FTWS_model1_gls_summary <- summary(birds_FTWS_model1_gls)

# Extract correlation structure parameters
print(birds_FTWS_model1_gls$modelStruct$corStruct)

# Get range parameter
birds_range_param <- coef(birds_FTWS_model1_gls$modelStruct$corStruct, unconstrained = FALSE)
```

```{r gls birds log}
#| label: fig-birds-gls-logged-values
#| echo: false
#| message: false
#| fig-width: 12
#| fig-height: 8
#| fig-cap: "Diagnostic plots for Bird GLS"

# Extract residuals
birds_residuals_gls <- residuals(birds_FTWS_model1_gls, type = "normalized")

# Get the data actually used in the model
birds_model_data <- getData(birds_FTWS_model1_gls)

# Basic residual plots
par(mfrow = c(2, 2))

# Residuals vs fitted
plot(fitted(birds_FTWS_model1_gls), birds_residuals_gls,
     xlab = "Fitted Values", ylab = "Normalized Residuals",
     main = "Residuals vs Fitted")
abline(h = 0, col = "red", lty = 2)

# QQ plot
qqnorm(birds_residuals_gls, main = "Normal Q-Q Plot")
qqline(birds_residuals_gls, col = "red")

# Residuals vs predictors
plot(birds_model_data$forest_to_tws, birds_residuals_gls,
     xlab = "Forest to TWS", ylab = "Normalized Residuals",
     main = "Residuals vs Forest to TWS")
abline(h = 0, col = "red", lty = 2)

plot(birds_model_data$log_recorder_effort, birds_residuals_gls,
     xlab = "Recorder Effort", ylab = "Normalized Residuals",
     main = "Residuals vs Recorder Effort")
abline(h = 0, col = "red", lty = 2)
```

The diagnostic plots suggest that:

1.  Residuals vs Fitted:
    -   There is a downward slope and fan shape =\> suggests non-constant variance and possible misspecification of the model
2.  QQ Plot:
    -   Relatively linear but with deviations at both ends
3.  Residuals vs Forest to TWS
    -   Some banding at low values but not too strong
4.  Residuals vs Recorder Effort
    -   Some funneling =\> might be concerning

Despite some of the issues in the diagnostic plots, this is the model we will use to keep consistent across analyses.

```{r gls birds summary}
#| label: tbl-gls-birds-values-summary
#| echo: false
#| tbl-cap: "GLS Model Coefficients Forest → TWS Effects on Birds Turnover"

# Extract model summary
model_summary_birds <- summary(birds_FTWS_model1_gls)
coef_table_birds <- model_summary_birds$tTable

# Create coefficient table without confidence intervals initially
model_coefs_birds <- data.frame(Variable = rownames(coef_table_birds),
                          Estimate = round(coef_table_birds[, "Value"], 4),
                          `Std Error` = round(coef_table_birds[, "Std.Error"], 4),
                          `t value` = round(coef_table_birds[, "t-value"], 3),
                          `p value` = coef_table_birds[, "p-value"],
                          check.names = FALSE)

# Add significance stars
model_coefs_birds$Significance <- case_when(model_coefs_birds$`p value` < 0.001 ~ "***",
                                      model_coefs_birds$`p value` < 0.01 ~ "**", 
                                      model_coefs_birds$`p value` < 0.05 ~ "*",
                                      model_coefs_birds$`p value` < 0.1 ~ ".",
                                      TRUE ~ "")

# Display using kable
knitr::kable(model_coefs_birds, digits = c(0, 4, 4, 3, 6, 0),
             format.args = list(scientific = FALSE))
```

```{r gls birds model fit statistics}
#| label: tbl-gls-birds-model-fit
#| echo: false
#| tbl-cap: "GLS Birds Model Fit Statistics"


# Model information
cat("Model Specifications:\n")
cat("- Formula:", deparse(birds_FTWS_model1_gls$call$model), "\n")
cat("- Correlation Structure: Exponential spatial correlation\n") 
cat("- Method: REML\n")

# Try to get sample size safely
n_obs <- tryCatch({model_summary_birds$dims$N
}, error = function(e) {
  nobs(birds_FTWS_model1_gls)
})

cat("- Number of observations:", n_obs, "\n")

# Model fit statistics
fit_stats <- data.frame(Statistic = c("AIC", "BIC", "Log-likelihood", "Residual Std Error"),
                        Value = c(round(AIC(birds_FTWS_model1_gls), 2),
                                  round(BIC(birds_FTWS_model1_gls), 2), 
                                  round(as.numeric(logLik(birds_FTWS_model1_gls)), 2),
                                  round(model_summary_birds$sigma, 4)))
knitr::kable(fit_stats, col.names = c("Statistic", "Value"))
```

```{r gls birds model output plot}
#| label: fig-gls-birds-coefficient-plot
#| echo: false
#| message: false
#| warning: false
#| fig-width: 6
#| fig-height: 4
#| fig-cap: "Coefficient Estimates from Birds GLS"

# Create dataframe of coeficients
birds_FTWS_model1_gls_coef_df <- data.frame(term = names(model_summary_birds$tTable[, "Value"]),
                                             estimate = model_summary_birds$tTable[, "Value"],
                                                   std.error = model_summary_birds$tTable[, "Std.Error"],
                                                   statistic = model_summary_birds$tTable[, "t-value"],
                                                   p.value = model_summary_birds$tTable[, "p-value"])

# Remove the intercept
birds_FTWS_model1_gls_coef_df_no_intercept <- birds_FTWS_model1_gls_coef_df[birds_FTWS_model1_gls_coef_df$term != "(Intercept)", ]

# Create coefficient plot
figure6_c <- ggplot(birds_FTWS_model1_gls_coef_df_no_intercept, aes(x = estimate, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = estimate - 1.96 * std.error,
                     xmax = estimate + 1.96 * std.error)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  scale_y_discrete(labels = c("forest_to_tws" = "Forest to TWS",
                              "forest_no_change" = "Forest No Change", 
                              "delta_recorder_effort" = "ΔRecorder Effort",
                              "log_recorder_effort" = "log Recorder Effort",
                              "lc_time_period2006-2012" = "2006-2012 Time Period",
                              "lc_time_period2012-2018" = "2012-2018 Time Period"),
                   limits = c("lc_time_period2012-2018",
                              "lc_time_period2006-2012", 
                              "log_recorder_effort",
                              "delta_recorder_effort",
                              "forest_no_change",
                              "forest_to_tws")) +
  labs(x = "Estimate ± 95% CI", y = NULL) +
  theme_classic()

# Display plot
figure6_c
```

### Trail 2: Weighted GLS

```{r weighted gls  diagnostics}
#| label: fig-birds-weighted-gls
#| echo: false
#| message: false
#| warning: false
#| fig-width: 12
#| fig-height: 8
#| fig-cap: "Diagnostic plots for birds weighted GLS model 2"

# Load model & data
load(here("data", "models", "exploratory",
          "birds_FTWS_model2_weighted_gls.RData"))

# Extract residuals
birds_residuals_weighted_gls <- residuals(birds_FTWS_model2_weighted_gls, type = "normalized")

# Basic residual plots
par(mfrow = c(2, 2))

# Residuals vs fitted
plot(fitted(birds_FTWS_model2_weighted_gls), birds_residuals_weighted_gls,
     xlab = "Fitted Values", ylab = "Normalized Residuals",
     main = "Residuals vs Fitted")
abline(h = 0, col = "red", lty = 2)

# QQ plot
qqnorm(birds_residuals_weighted_gls, main = "Normal Q-Q Plot")
qqline(birds_residuals_weighted_gls, col = "red")

# Residuals vs predictors
plot(birds_turnover_forest_tws_15km_coords_time$forest_to_tws, birds_residuals_weighted_gls,
     xlab = "Forest to TWS", ylab = "Normalized Residuals",
     main = "Residuals vs Forest to TWS")
abline(h = 0, col = "red", lty = 2)

plot(birds_turnover_forest_tws_15km_coords_time$log_recorder_effort, birds_residuals_weighted_gls,
     xlab = "Recorder Effort", ylab = "Normalized Residuals",
     main = "Residuals vs Recorder Effort")
abline(h = 0, col = "red", lty = 2)
```

Model diagnostic are showing the same issues as the unweighted version of the model. Will try a GAM just to see as well.

### Trial 3: GAM with spatial smoother

```{r birds gam}
#| label: fig-birds-gam-check
#| echo: false
#| message: false
#| fig-width: 12
#| fig-height: 8
#| fig-cap: "Diagnostic plots for GAM model for bird occurrences"

# Load model
load(here("data", "models", "exploratory", "birds_FTWS_model3_GAM.RData"))

# Diagnostic plots
par(mfrow = c(2, 2))
gam.check(birds_FTWS_model3_GAM)
```

The model diagnostics show serious issues upon closer inspection. Best way to proceed is with the GLS.
